<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ãƒ—å£ã‚¸ã‚§ã‚¯ãƒˆï¼¸</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.0/font/bootstrap-icons.css" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 16px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.3);
            padding: 8px 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            cursor: pointer;
            transition: background 0.3s ease;
        }
        
        #info:hover {
            background: rgba(0, 0, 0, 0.4);
        }
        
        #info h3 {
            margin: 0;
        }
        
        #modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            display: none;
            justify-content: center;
            align-items: center;
        }
        
        #modal-content {
            background: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 15px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            color: #333;
        }
        
        #modal-content h2 {
            margin-top: 0;
            color: #4a5568;
            text-align: center;
            border-bottom: 2px solid #e2e8f0;
            padding-bottom: 10px;
        }
        
        #modal-content h3 {
            color: #2d3748;
            margin-top: 20px;
            margin-bottom: 10px;
        }
        
        #modal-content ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        
        #modal-content li {
            margin: 5px 0;
            line-height: 1.4;
        }
        
        .close-button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 20px;
            display: block;
            margin-left: auto;
            margin-right: auto;
        }
        
        .close-button:hover {
            background: #5a67d8;
        }
        
        #input-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            display: none;
            justify-content: center;
            align-items: center;
        }
        
        #input-modal-content {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            max-width: 90vw;
            width: 400px;
            max-height: 80vh;
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            color: #333;
            box-sizing: border-box;
        }
        
        #input-modal-content h2 {
            margin-top: 0;
            color: #4a5568;
            text-align: center;
            border-bottom: 2px solid #e2e8f0;
            padding-bottom: 10px;
        }
        
        #move-input {
            width: 100%;
            padding: 15px;
            font-size: 16px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            margin: 15px 0;
            font-family: monospace;
            box-sizing: border-box;
            resize: none;
            background-color: #f8f9fa;
            cursor: default;
        }
        
        #move-input:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .input-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }
        
        .input-button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
        }
        
        .go-button {
            background: #48bb78;
            color: white;
        }
        
        .go-button:hover {
            background: #38a169;
        }
        
        .cancel-button {
            background: #e53e3e;
            color: white;
        }
        
        .cancel-button:hover {
            background: #c53030;
        }
        
        .notation-buttons {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 8px;
            margin: 15px 0;
        }
        
        .notation-button {
            padding: 8px 4px;
            border: 1px solid #cbd5e0;
            border-radius: 6px;
            background: #f7fafc;
            color: #2d3748;
            cursor: pointer;
            font-size: 14px;
            font-family: monospace;
            transition: all 0.2s ease;
        }
        
        .notation-button:hover {
            background: #e2e8f0;
            border-color: #a0aec0;
        }
        
        .notation-button:active {
            background: #cbd5e0;
        }
        
        #controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 100;
        }
        
        button {
            padding: 12px 20px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 50px;
            min-height: 50px;
        }
        
        button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }
        
        button:active {
            transform: translateY(0);
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="info" onclick="showControls()">
            <h3>ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆX</h3>
        </div>
        <div id="reset-controls" style="position: absolute; top: 70px; left: 20px; z-index: 100; background: rgba(0, 0, 0, 0.3); padding: 10px; border-radius: 10px; backdrop-filter: blur(10px);">
            <div style="color: white; font-size: 14px; margin-bottom: 8px; text-align: left;">ãƒªã‚»ãƒƒãƒˆ</div>
            <div style="display: flex; gap: 10px;">
                <button onclick="resetToScrambled()" title="ã‚¹ã‚¯ãƒ©ãƒ³ãƒ–ãƒ«ãƒªã‚»ãƒƒãƒˆ">
                    <img src="https://img.icons8.com/?size=20&id=37981&format=png&color=ffffff" alt="reset" style="width: 20px; height: 20px;">
                </button>
                <button onclick="resetCamera()" title="ã‚«ãƒ¡ãƒ©ãƒªã‚»ãƒƒãƒˆ"><i class="bi bi-camera-fill"></i></button>
            </div>
        </div>
        <div id="controls">
            <select id="scramble-length" style="padding: 12px; background: rgba(255, 255, 255, 0.2); border: 2px solid rgba(255, 255, 255, 0.3); color: white; border-radius: 8px; cursor: pointer; font-size: 14px; backdrop-filter: blur(10px); margin-right: 10px;">
                <option value="1" style="background: #333; color: white;">1æ‰‹</option>
                <option value="2" style="background: #333; color: white;">2æ‰‹</option>
                <option value="3" style="background: #333; color: white;">3æ‰‹</option>
                <option value="4" style="background: #333; color: white;">4æ‰‹</option>
                <option value="5" style="background: #333; color: white;" selected>5æ‰‹</option>
                <option value="6" style="background: #333; color: white;">6æ‰‹</option>
                <option value="7" style="background: #333; color: white;">7æ‰‹</option>
                <option value="8" style="background: #333; color: white;">8æ‰‹</option>
                <option value="9" style="background: #333; color: white;">9æ‰‹</option>
                <option value="10" style="background: #333; color: white;">10æ‰‹</option>
                <option value="11" style="background: #333; color: white;">11æ‰‹</option>
                <option value="12" style="background: #333; color: white;">12æ‰‹</option>
            </select>
            <select id="scramble-type" style="padding: 12px; background: rgba(255, 255, 255, 0.2); border: 2px solid rgba(255, 255, 255, 0.3); color: white; border-radius: 8px; cursor: pointer; font-size: 14px; backdrop-filter: blur(10px); margin-right: 10px;">
                <option value="exact" style="background: #333; color: white;" selected>å›ºå®š</option>
                <option value="within" style="background: #333; color: white;">ä»¥å†…</option>
            </select>
            <button onclick="scrambleWithSelectedLength()" style="padding: 12px 20px; background: rgba(255, 255, 255, 0.2); border: 2px solid rgba(255, 255, 255, 0.3); color: white; border-radius: 8px; cursor: pointer; font-size: 14px; transition: all 0.3s ease; backdrop-filter: blur(10px);" onmouseover="this.style.background='rgba(255, 255, 255, 0.3)'; this.style.transform='translateY(-2px)'" onmouseout="this.style.background='rgba(255, 255, 255, 0.2)'; this.style.transform='translateY(0)'">å´©ã™</button>
            <button onclick="solveCube()" style="padding: 12px 20px; background: rgba(255, 255, 255, 0.2); border: 2px solid rgba(255, 255, 255, 0.3); color: white; border-radius: 8px; cursor: pointer; font-size: 14px; transition: all 0.3s ease; backdrop-filter: blur(10px);" onmouseover="this.style.background='rgba(255, 255, 255, 0.3)'; this.style.transform='translateY(-2px)'" onmouseout="this.style.background='rgba(255, 255, 255, 0.2)'; this.style.transform='translateY(0)'">æƒãˆã‚‹</button>
        </div>
        <div id="game-info" style="position: absolute; top: 20px; right: 20px; color: white; background: rgba(0, 0, 0, 0.3); padding: 15px; border-radius: 10px; backdrop-filter: blur(10px);">
            <div id="move-counter">æ‰‹æ•°: 0</div>
            <div id="scramble-info"></div>
        </div>
        
        <!-- æ“ä½œæ–¹æ³•ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ— -->
        <div id="modal-overlay" onclick="hideControls()">
            <div id="modal-content" onclick="event.stopPropagation()">
                <h2>ğŸ“‹ æ“ä½œæ–¹æ³•</h2>
                
                <h3>ğŸ–±ï¸ ãƒã‚¦ã‚¹æ“ä½œ</h3>
                <ul>
                    <li><strong>ãƒ‰ãƒ©ãƒƒã‚°</strong>ï¼šã‚­ãƒ¥ãƒ¼ãƒ–ã‚’è‡ªç”±ã«å›è»¢</li>
                    <li><strong>ãƒ›ã‚¤ãƒ¼ãƒ«</strong>ï¼šã‚ºãƒ¼ãƒ ã‚¤ãƒ³ãƒ»ã‚ºãƒ¼ãƒ ã‚¢ã‚¦ãƒˆ</li>
                </ul>
                
                <h3>âŒ¨ï¸ ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰æ“ä½œï¼ˆã‚²ãƒ¼ãƒ ä¸­ã®ã¿ï¼‰</h3>
                <ul>
                    <li><strong>R, L, U, D, F, B</strong>ï¼šå„é¢ã®å›è»¢</li>
                    <li><strong>Shift + R, L, U, D, F, B</strong>ï¼šå„é¢ã®é€†å›è»¢</li>
                    <li><strong>Ctrl/Cmd + R, L, U, D, F, B</strong>ï¼šå„é¢ã®180åº¦å›è»¢</li>
                    <li><strong>Alt + U</strong>ï¼šUwï¼ˆä¸Šé¢ãƒ¯ã‚¤ãƒ‰å›è»¢ï¼‰</li>
                    <li><strong>Alt + Shift + U</strong>ï¼šUw'ï¼ˆä¸Šé¢ãƒ¯ã‚¤ãƒ‰å›è»¢ é€†ï¼‰</li>
                    <li><strong>y</strong>ï¼šã‚­ãƒ¥ãƒ¼ãƒ–å…¨ä½“ã®yè»¸å›è»¢ï¼ˆæŒã¡æ›¿ãˆï¼‰</li>
                    <li><strong>Shift + y</strong>ï¼šã‚­ãƒ¥ãƒ¼ãƒ–å…¨ä½“ã®yè»¸é€†å›è»¢</li>
                </ul>
                
                <h3>ğŸ® ã‚²ãƒ¼ãƒ ã®æµã‚Œ</h3>
                <ul>
                    <li><strong>æ‰‹æ•°ã¨ã‚¿ã‚¤ãƒ—ã‚’é¸æŠ</strong>ï¼š1-12æ‰‹ã€å›ºå®š/ä»¥å†…ã‚’é¸æŠ</li>
                    <li><strong>ã€Œå´©ã™ã€</strong>ï¼šX-crosså®ŒæˆçŠ¶æ…‹ã‹ã‚‰æŒ‡å®šæ¡ä»¶ã§ã‚¹ã‚¯ãƒ©ãƒ³ãƒ–ãƒ«</li>
                    <li><strong>ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰æ“ä½œ</strong>ï¼šX-crosså®ŒæˆçŠ¶æ…‹ã«æˆ»ã™</li>
                    <li><strong>ã€Œæƒãˆã‚‹ã€</strong>ï¼šå›è»¢è¨˜å·ã‚’ãƒœã‚¿ãƒ³ã§å…¥åŠ›ã—ã¦å®Ÿè¡Œ</li>
                    <li><strong>ãƒªã‚»ãƒƒãƒˆæ©Ÿèƒ½</strong>ï¼šğŸ”—ã§ã‚¹ã‚¯ãƒ©ãƒ³ãƒ–ãƒ«çŠ¶æ…‹ã«æˆ»ã™ã€ğŸ“·ã§ã‚«ãƒ¡ãƒ©ä½ç½®ãƒªã‚»ãƒƒãƒˆ</li>
                </ul>
                
                <h3>ğŸ”§ ãã®ä»–ã®æ©Ÿèƒ½</h3>
                <ul>
                    <li><strong>å›è»¢è¨˜å·å…¥åŠ›</strong>ï¼šã€Œæƒãˆã‚‹ã€ãƒœã‚¿ãƒ³ã§å…¥åŠ›ç”»é¢ã‚’é–‹ã</li>
                    <li><strong>å…¥åŠ›æ–¹æ³•</strong>ï¼šãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯ã®ã¿ï¼ˆã‚­ãƒ¼ãƒœãƒ¼ãƒ‰å…¥åŠ›ç„¡åŠ¹ï¼‰</li>
                    <li><strong>å¯¾å¿œè¨˜å·</strong>ï¼šR, L, U, D, F, Bï¼ˆ', 2ä»˜ãï¼‰ã€Uw, Uw', y, y'</li>
                    <li><strong>ç·¨é›†æ©Ÿèƒ½</strong>ï¼šâ†ã§å–æ¶ˆã€ã‚¯ãƒªã‚¢ã§å…¨å‰Šé™¤</li>
                </ul>
                
                <h3>ğŸ“± ã‚¿ãƒƒãƒæ“ä½œ</h3>
                <ul>
                    <li><strong>ã‚¿ãƒƒãƒ&ãƒ‰ãƒ©ãƒƒã‚°</strong>ï¼šã‚­ãƒ¥ãƒ¼ãƒ–ã‚’å›è»¢</li>
                    <li><strong>ãƒ”ãƒ³ãƒ</strong>ï¼šã‚ºãƒ¼ãƒ ï¼ˆä¸€éƒ¨ãƒ‡ãƒã‚¤ã‚¹ï¼‰</li>
                </ul>
                
                <button class="close-button" onclick="hideControls()">é–‰ã˜ã‚‹</button>
            </div>
        </div>
        
        <!-- å›è»¢å…¥åŠ›ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ— -->
        <div id="input-modal-overlay" onclick="hideInputModal()">
            <div id="input-modal-content" onclick="event.stopPropagation()">
                <textarea id="move-input" placeholder="å›è»¢è¨˜å·ãƒœã‚¿ãƒ³ã§å…¥åŠ›ã—ã¦ãã ã•ã„" rows="4" readonly></textarea>
                
                <div class="notation-buttons">
                    <button class="notation-button" onclick="addNotation('R')">R</button>
                    <button class="notation-button" onclick="addNotation('R\'')">R'</button>
                    <button class="notation-button" onclick="addNotation('R2')">R2</button>
                    <button class="notation-button" onclick="addNotation('L')">L</button>
                    <button class="notation-button" onclick="addNotation('L\'')">L'</button>
                    <button class="notation-button" onclick="addNotation('L2')">L2</button>
                    
                    <button class="notation-button" onclick="addNotation('U')">U</button>
                    <button class="notation-button" onclick="addNotation('U\'')">U'</button>
                    <button class="notation-button" onclick="addNotation('U2')">U2</button>
                    <button class="notation-button" onclick="addNotation('D')">D</button>
                    <button class="notation-button" onclick="addNotation('D\'')">D'</button>
                    <button class="notation-button" onclick="addNotation('D2')">D2</button>
                    
                    <button class="notation-button" onclick="addNotation('F')">F</button>
                    <button class="notation-button" onclick="addNotation('F\'')">F'</button>
                    <button class="notation-button" onclick="addNotation('F2')">F2</button>
                    <button class="notation-button" onclick="addNotation('B')">B</button>
                    <button class="notation-button" onclick="addNotation('B\'')">B'</button>
                    <button class="notation-button" onclick="addNotation('B2')">B2</button>
                    
                    <button class="notation-button" onclick="addNotation('Uw')">Uw</button>
                    <button class="notation-button" onclick="addNotation('Uw\'')">Uw'</button>
                    <button class="notation-button" onclick="addNotation('y')">y</button>
                    <button class="notation-button" onclick="addNotation('y\'')">y'</button>
                    <button class="notation-button" onclick="undoLastMove()">â†</button>
                    <button class="notation-button" onclick="clearInput()">ã‚¯ãƒªã‚¢</button>
                </div>
                
                <div class="input-buttons">
                    <button class="input-button go-button" onclick="executeInputMoves()">Go!</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, cube, cubeGroup;
        let mouseX = 0, mouseY = 0;
        let isMouseDown = false;
        let moveCount = 0;
        let isGameMode = false;
        let scrambleSequence = [];
        let solutionSequence = [];
        let cubeState = []; // ã‚­ãƒ¥ãƒ¼ãƒ–ã®çŠ¶æ…‹ã‚’ä¿å­˜
        
        // å›è»¢ã®å®šç¾©
        const moves = ['R', 'R\'', 'R2', 'L', 'L\'', 'L2', 'U', 'U\'', 'U2', 'Uw', 'Uw\'', 'D', 'D\'', 'D2', 'F', 'F\'', 'F2', 'B', 'B\'', 'B2'];
        
        // å®ŒæˆçŠ¶æ…‹ã®å®šç¾©
        const solvedState = {
            centers: true,
            whiteEdges: true,
            blueOrangeF2L: true
        };
        
        // ãƒ«ãƒ¼ãƒ“ãƒƒã‚¯ã‚­ãƒ¥ãƒ¼ãƒ–ã®è‰²å®šç¾©
        const colors = {
            front: 0xff0000,   // èµ¤
            back: 0xff8c00,    // ã‚ªãƒ¬ãƒ³ã‚¸  
            right: 0x00ff00,   // ç·‘
            left: 0x0000ff,    // é’
            top: 0xffffff,     // ç™½
            bottom: 0xffff00   // é»„
        };

        function init() {
            // ã‚·ãƒ¼ãƒ³ä½œæˆ
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);

            // ã‚«ãƒ¡ãƒ©ä½œæˆ
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(4, 3, 6);
            camera.lookAt(0, 0, 0);

            // ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ä½œæˆ
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);

            // ãƒ©ã‚¤ãƒ†ã‚£ãƒ³ã‚°
            const ambientLight = new THREE.AmbientLight(0x404040, 1.0); // ã‚¢ãƒ³ãƒ“ã‚¨ãƒ³ãƒˆãƒ©ã‚¤ãƒˆã‚’å¼·åŒ–
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6); // ãƒ‡ã‚£ãƒ¬ã‚¯ã‚·ãƒ§ãƒŠãƒ«ãƒ©ã‚¤ãƒˆã‚’å¼±åŒ–
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // è¿½åŠ ã®è£œåŠ©ãƒ©ã‚¤ãƒˆï¼ˆå½±ã‚’è»½æ¸›ï¼‰
            const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
            fillLight.position.set(-10, -10, -5); // åå¯¾æ–¹å‘ã‹ã‚‰ç…§å°„
            scene.add(fillLight);

            // ãƒ«ãƒ¼ãƒ“ãƒƒã‚¯ã‚­ãƒ¥ãƒ¼ãƒ–ä½œæˆ
            createRubiksCube();

            // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
            setupEventListeners();

            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—é–‹å§‹
            animate();
        }

        function createRubiksCube() {
            cubeGroup = new THREE.Group();
            
            const cubeSize = 0.9;
            const gap = 0.05;
            const totalSize = cubeSize + gap;

            for (let x = 0; x < 3; x++) {
                for (let y = 0; y < 3; y++) {
                    for (let z = 0; z < 3; z++) {
                        // ã‚»ãƒ³ã‚¿ãƒ¼ãƒ‘ãƒ¼ãƒ„ã‹ã©ã†ã‹ã‚’åˆ¤å®š
                        const isCenter = (x === 1 && y === 1) || (x === 1 && z === 1) || (y === 1 && z === 1);
                        
                        // ç™½è‰²ã®ã‚¨ãƒƒã‚¸ãƒ‘ãƒ¼ãƒ„ã‹ã©ã†ã‹ã‚’åˆ¤å®šï¼ˆåº•é¢ã®åå­—ï¼‰
                        const isWhiteEdge = (y === 0) && // åº•é¢ã«ã‚ã‚‹
                                          ((x === 1 && z !== 1) || (z === 1 && x !== 1)); // ã‚¨ãƒƒã‚¸ã®ä½ç½®
                        
                        // é’ã¨ã‚ªãƒ¬ãƒ³ã‚¸ã®F2Lãƒšã‚¢ï¼ˆå·¦å´é¢-èƒŒé¢ã®ã‚³ãƒ¼ãƒŠãƒ¼ï¼‰ã‹ã©ã†ã‹ã‚’åˆ¤å®š
                        const isBlueOrangeF2L = (x === 0 && z === 0) && (y === 0 || y === 1); // å·¦å¾Œã®ã‚³ãƒ¼ãƒŠãƒ¼ã¨ã‚¨ãƒƒã‚¸ï¼ˆé’ã¯å·¦å´é¢ã€ã‚ªãƒ¬ãƒ³ã‚¸ã¯èƒŒé¢ï¼‰
                        
                        const smallCube = createSmallCube(cubeSize, isCenter, isWhiteEdge, isBlueOrangeF2L);
                        smallCube.position.set(
                            (x - 1) * totalSize,
                            (y - 1) * totalSize,
                            (z - 1) * totalSize
                        );
                        cubeGroup.add(smallCube);
                    }
                }
            }

            scene.add(cubeGroup);
        }

        function createSmallCube(size, isCenter = false, isWhiteEdge = false, isBlueOrangeF2L = false) {
            const geometry = new THREE.BoxGeometry(size, size, size);
            
            let materials;
            
            if (isCenter || isWhiteEdge || isBlueOrangeF2L) {
                // ã‚»ãƒ³ã‚¿ãƒ¼ãƒ‘ãƒ¼ãƒ„ã€ç™½è‰²ã‚¨ãƒƒã‚¸ãƒ‘ãƒ¼ãƒ„ã€ã¾ãŸã¯é’ã‚ªãƒ¬ãƒ³ã‚¸F2Lãƒšã‚¢ã¯å…ƒã®è‰²ã‚’ç¶­æŒ
                materials = [
                    new THREE.MeshLambertMaterial({ color: colors.right }),  // å³ï¼ˆç·‘ï¼‰
                    new THREE.MeshLambertMaterial({ color: colors.left }),   // å·¦ï¼ˆé’ï¼‰
                    new THREE.MeshLambertMaterial({ color: colors.bottom }), // ä¸Šï¼ˆé»„ï¼‰
                    new THREE.MeshLambertMaterial({ color: colors.top }),    // ä¸‹ï¼ˆç™½ï¼‰
                    new THREE.MeshLambertMaterial({ color: colors.front }),  // å‰ï¼ˆèµ¤ï¼‰
                    new THREE.MeshLambertMaterial({ color: colors.back })    // å¾Œï¼ˆã‚ªãƒ¬ãƒ³ã‚¸ï¼‰
                ];
            } else {
                // ãã®ä»–ã®ãƒ‘ãƒ¼ãƒ„ï¼ˆF2Lãƒšã‚¢ã‚’å«ã‚€ï¼‰ã¯ã™ã¹ã¦ã‚°ãƒ¬ãƒ¼
                const grayMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
                materials = [grayMaterial, grayMaterial, grayMaterial, grayMaterial, grayMaterial, grayMaterial];
            }

            const cube = new THREE.Mesh(geometry, materials);
            cube.castShadow = true;
            cube.receiveShadow = true;

            // ã‚¨ãƒƒã‚¸ã‚’è¿½åŠ ã—ã¦ã‚ˆã‚Šãƒªã‚¢ãƒ«ã«
            const edges = new THREE.EdgesGeometry(geometry);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 }));
            cube.add(line);

            return cube;
        }

        function setupEventListeners() {
            // ãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆ
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('wheel', onWheel);

            // ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆ
            renderer.domElement.addEventListener('touchstart', onTouchStart);
            renderer.domElement.addEventListener('touchmove', onTouchMove);
            renderer.domElement.addEventListener('touchend', onTouchEnd);

            // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆå›è»¢æ“ä½œç”¨ï¼‰
            window.addEventListener('keydown', onKeyDown);
            
            // ãƒªã‚µã‚¤ã‚ºã‚¤ãƒ™ãƒ³ãƒˆ
            window.addEventListener('resize', onWindowResize);
        }

        function onKeyDown(event) {
            if (!isGameMode) return;
            
            const key = event.key.toLowerCase();
            let move = '';
            
            switch(key) {
                case 'r': 
                    if (event.ctrlKey || event.metaKey) {
                        move = 'R2';
                    } else {
                        move = event.shiftKey ? 'R' : 'R\'';
                    }
                    break;
                case 'l': 
                    if (event.ctrlKey || event.metaKey) {
                        move = 'L2';
                    } else {
                        move = event.shiftKey ? 'L\'' : 'L';
                    }
                    break;
                case 'u': 
                    if (event.altKey) {
                        // Alt + U ã§ Uwï¼ˆãƒ¯ã‚¤ãƒ‰å›è»¢ï¼‰
                        move = event.shiftKey ? 'Uw' : 'Uw\'';
                    } else if (event.ctrlKey || event.metaKey) {
                        move = 'U2';
                    } else {
                        move = event.shiftKey ? 'U' : 'U\'';
                    }
                    break;
                case 'd': 
                    if (event.ctrlKey || event.metaKey) {
                        move = 'D2';
                    } else {
                        move = event.shiftKey ? 'D\'' : 'D';
                    }
                    break;
                case 'f': 
                    if (event.ctrlKey || event.metaKey) {
                        move = 'F2';
                    } else {
                        move = event.shiftKey ? 'F' : 'F\'';
                    }
                    break;
                case 'b': 
                    if (event.ctrlKey || event.metaKey) {
                        move = 'B2';
                    } else {
                        move = event.shiftKey ? 'B\'' : 'B';
                    }
                    break;
                case 'y': move = event.shiftKey ? 'y\'' : 'y'; break;
            }
            
            if (move) {
                if (move === 'y' || move === 'y\'') {
                    executeYRotation(move);
                } else {
                    executeMove(move);
                    moveCount++;
                }
                updateGameInfo();
                checkSolved();
            }
        }

        function onMouseDown(event) {
            isMouseDown = true;
            mouseX = event.clientX;
            mouseY = event.clientY;
        }

        function onMouseMove(event) {
            if (!isMouseDown) return;

            const deltaX = event.clientX - mouseX;
            const deltaY = event.clientY - mouseY;

            cubeGroup.rotation.y += deltaX * 0.01;
            cubeGroup.rotation.x += deltaY * 0.01;

            mouseX = event.clientX;
            mouseY = event.clientY;
        }

        function onMouseUp(event) {
            isMouseDown = false;
        }

        function onWheel(event) {
            camera.position.multiplyScalar(event.deltaY > 0 ? 1.1 : 0.9);
            camera.position.clampLength(3, 20);
        }

        function onTouchStart(event) {
            if (event.touches.length === 1) {
                mouseX = event.touches[0].clientX;
                mouseY = event.touches[0].clientY;
                isMouseDown = true;
            }
        }

        function onTouchMove(event) {
            event.preventDefault();
            if (event.touches.length === 1 && isMouseDown) {
                const deltaX = event.touches[0].clientX - mouseX;
                const deltaY = event.touches[0].clientY - mouseY;

                cubeGroup.rotation.y += deltaX * 0.01;
                cubeGroup.rotation.x += deltaY * 0.01;

                mouseX = event.touches[0].clientX;
                mouseY = event.touches[0].clientY;
            }
        }

        function onTouchEnd(event) {
            isMouseDown = false;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function scrambleCube() {
            cubeGroup.children.forEach(cube => {
                // ãƒ©ãƒ³ãƒ€ãƒ ãªä½ç½®ã«ç§»å‹•
                cube.position.add(new THREE.Vector3(
                    (Math.random() - 0.5) * 0.2,
                    (Math.random() - 0.5) * 0.2,
                    (Math.random() - 0.5) * 0.2
                ));
                
                // ãƒ©ãƒ³ãƒ€ãƒ ãªå›è»¢
                cube.rotation.set(
                    Math.random() * Math.PI * 2,
                    Math.random() * Math.PI * 2,
                    Math.random() * Math.PI * 2
                );
            });
        }

        function solveCube() {
            showInputModal();
        }
        
        function showInputModal() {
            document.getElementById('input-modal-overlay').style.display = 'flex';
            document.getElementById('move-input').focus();
        }
        
        function hideInputModal() {
            document.getElementById('input-modal-overlay').style.display = 'none';
            document.getElementById('move-input').value = '';
        }
        
        function addNotation(notation) {
            const input = document.getElementById('move-input');
            if (input.value && !input.value.endsWith(' ')) {
                input.value += ' ';
            }
            input.value += notation;
        }
        
        function clearInput() {
            document.getElementById('move-input').value = '';
        }
        
        function undoLastMove() {
            const input = document.getElementById('move-input');
            const moves = input.value.trim().split(/\s+/);
            if (moves.length > 0 && moves[0] !== '') {
                moves.pop();
                input.value = moves.join(' ');
                if (input.value.length > 0) {
                    input.value += ' ';
                }
            }
        }

        function executeInputMoves() {
            const input = document.getElementById('move-input').value.trim();
            if (!input) {
                alert('å›è»¢è¨˜å·ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚');
                return;
            }
            
            // å…¥åŠ›ã•ã‚ŒãŸæ‰‹é †ã‚’è§£æ
            const moves = input.split(/\s+/).filter(move => move.length > 0);
            
            // æœ‰åŠ¹ãªæ‰‹é †ã‹ãƒã‚§ãƒƒã‚¯
            const validMoves = ['R', 'R\'', 'R2', 'L', 'L\'', 'L2', 'U', 'U\'', 'U2', 'Uw', 'Uw\'', 'D', 'D\'', 'D2', 'F', 'F\'', 'F2', 'B', 'B\'', 'B2', 'y', 'y\''];
            const invalidMoves = moves.filter(move => !validMoves.includes(move));
            
            if (invalidMoves.length > 0) {
                alert(`ç„¡åŠ¹ãªå›è»¢è¨˜å·ãŒå«ã¾ã‚Œã¦ã„ã¾ã™: ${invalidMoves.join(', ')}`);
                return;
            }
            
            hideInputModal();
            
            // å…¥åŠ›ã•ã‚ŒãŸæ‰‹é †ã‚’å®Ÿè¡Œç”¨ã«å¤‰æ›ï¼ˆR, U, F, Uwã®å›è»¢ã‚’é€†ã«å¤‰æ›ï¼‰
            const convertedMoves = moves.map(move => {
                if (move.includes('2')) {
                    return move; // 180åº¦å›è»¢ã¯ãã®ã¾ã¾
                }
                const base = move.replace('\'', '').replace('w', '');
                if (base === 'R' || base === 'U' || base === 'F') {
                    return move.includes('\'') ? move.replace('\'', '') : move + '\'';
                }
                return move;
            });
            
            // æ‰‹é †ã‚’é †æ¬¡å®Ÿè¡Œ
            convertedMoves.forEach((move, index) => {
                setTimeout(() => {
                    if (move === 'y' || move === 'y\'') {
                        executeYRotation(move);
                    } else {
                        executeMove(move);
                        if (isGameMode) {
                            moveCount++;
                            updateGameInfo();
                        }
                    }
                    
                    // æœ€å¾Œã®æ‰‹é †ã®å¾Œã«å®Œæˆãƒã‚§ãƒƒã‚¯
                    if (index === convertedMoves.length - 1 && isGameMode) {
                        setTimeout(() => {
                            checkSolved();
                        }, 100);
                    }
                }, index * 300); // 300msé–“éš”ã§å®Ÿè¡Œ
            });
        }

        function showControls() {
            document.getElementById('modal-overlay').style.display = 'flex';
        }
        
        function hideControls() {
            document.getElementById('modal-overlay').style.display = 'none';
        }

        function resetCamera() {
            // ã‚«ãƒ¡ãƒ©ã‚’åˆæœŸä½ç½®ã«æˆ»ã™
            camera.position.set(4, 3, 6);
            camera.lookAt(0, 0, 0);
            camera.up.set(0, 1, 0); // ã‚«ãƒ¡ãƒ©ã®ä¸Šæ–¹å‘ã‚’ãƒªã‚»ãƒƒãƒˆ
            camera.updateProjectionMatrix();
            camera.updateMatrixWorld();
            
            // ã‚­ãƒ¥ãƒ¼ãƒ–ã®å›è»¢ã‚‚ãƒªã‚»ãƒƒãƒˆ
            cubeGroup.rotation.set(0, 0, 0);
        }

        function resetCube() {
            cubeGroup.children.forEach((cube, index) => {
                const x = index % 3;
                const y = Math.floor((index % 9) / 3);
                const z = Math.floor(index / 9);
                
                const cubeSize = 0.9;
                const gap = 0.05;
                const totalSize = cubeSize + gap;
                
                // ä½ç½®ã‚’ãƒªã‚»ãƒƒãƒˆ
                cube.position.set(
                    (x - 1) * totalSize,
                    (y - 1) * totalSize,
                    (z - 1) * totalSize
                );
                
                // å›è»¢ã‚’ãƒªã‚»ãƒƒãƒˆ
                cube.rotation.set(0, 0, 0);
                cube.quaternion.set(0, 0, 0, 1);
            });
            
            // ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
            moveCount = 0;
            isGameMode = false;
            scrambleSequence = [];
            solutionSequence = [];
            updateGameInfo();
            document.getElementById('scramble-info').innerHTML = '';
        }

        let scrambledState = null; // 5æ‰‹å´©ã—ãŸçŠ¶æ…‹ã‚’ä¿å­˜

        function scrambleWithSelectedLength() {
            const lengthSelect = document.getElementById('scramble-length');
            const typeSelect = document.getElementById('scramble-type');
            const maxMoves = parseInt(lengthSelect.value);
            const isExact = typeSelect.value === 'exact';
            
            let numMoves;
            if (isExact) {
                // ã¡ã‚‡ã†ã©næ‰‹
                numMoves = maxMoves;
            } else {
                // næ‰‹ä»¥å†…ï¼ˆ1æ‰‹ã‹ã‚‰næ‰‹ã®ãƒ©ãƒ³ãƒ€ãƒ ï¼‰
                numMoves = Math.floor(Math.random() * maxMoves) + 1;
            }
            
            scrambleFromSolved(numMoves);
        }

        function scrambleFromSolved(numMoves) {
            resetCube();
            scrambleSequence = [];
            solutionSequence = [];
            
            // ãƒ©ãƒ³ãƒ€ãƒ ãªæ‰‹é †ã‚’ç”Ÿæˆ
            for (let i = 0; i < numMoves; i++) {
                let randomMove;
                do {
                    randomMove = moves[Math.floor(Math.random() * moves.length)];
                    
                } while (
                    // æœ€åˆã®æ‰‹é †ã§Uç³»ã‚’é¿ã‘ã‚‹
                    (i === 0 && randomMove.replace('\'', '').replace('2', '').replace('w', '') === 'U') ||
                    
                    // 2æ‰‹ç›®ã§ç‰¹åˆ¥ãªæ¡ä»¶ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆ1æ‰‹ç›®ãŒDç³»ã®å ´åˆã€2æ‰‹ç›®ã¯Uç³»ã‚’é¿ã‘ã‚‹ï¼‰
                    (i === 1 && scrambleSequence.length > 0 && 
                     scrambleSequence[0].replace('\'', '').replace('2', '').replace('w', '') === 'D' &&
                     randomMove.replace('\'', '').replace('2', '').replace('w', '') === 'U') ||
                    
                    // é€£ç¶šåŒè»¸å›é¿
                    (scrambleSequence.length > 0 && isSameAxis(randomMove, scrambleSequence[scrambleSequence.length - 1])) ||
                    
                    // å¯¾é¢è»¸ãƒ‘ã‚¿ãƒ¼ãƒ³å›é¿
                    (scrambleSequence.length >= 2 && isOppositeAxisPattern(randomMove, scrambleSequence))
                );
                
                scrambleSequence.push(randomMove);
                // è§£æ³•ã¯é€†é †ã§é€†ã®æ‰‹é †
                solutionSequence.unshift(getInverseMove(randomMove));
            }
            
            // ã‚¹ã‚¯ãƒ©ãƒ³ãƒ–ãƒ«ã‚’å®Ÿè¡Œï¼ˆè¦–è¦šçš„ã«ã¯è¦‹ã›ãªã„ï¼‰
            scrambleSequence.forEach(move => {
                executeMove(move, false);
            });
            
            // å´©ã—ãŸçŠ¶æ…‹ã‚’ä¿å­˜
            scrambledState = cubeGroup.children.map(cube => ({
                position: cube.position.clone(),
                quaternion: cube.quaternion.clone()
            }));
            
            // ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰é–‹å§‹
            moveCount = 0;
            isGameMode = true;
            updateGameInfo();
            
            // è¡¨ç¤ºç”¨ã®ã‚¹ã‚¯ãƒ©ãƒ³ãƒ–ãƒ«ã¨è§£æ³•ã‚’ä¿®æ­£ï¼ˆR, U, F, Uwã®å›è»¢ã‚’é€†ã«è¡¨ç¤ºï¼‰
            const displayScramble = scrambleSequence.map(move => {
                if (move.includes('2')) {
                    return move; // 180åº¦å›è»¢ã¯ãã®ã¾ã¾
                }
                const base = move.replace('\'', '').replace('w', '');
                if (base === 'R' || base === 'U' || base === 'F') {
                    return move.includes('\'') ? move.replace('\'', '') : move + '\'';
                }
                return move;
            });
            
            const displaySolution = solutionSequence.map(move => {
                if (move.includes('2')) {
                    return move; // 180åº¦å›è»¢ã¯ãã®ã¾ã¾
                }
                const base = move.replace('\'', '').replace('w', '');
                if (base === 'R' || base === 'U' || base === 'F') {
                    return move.includes('\'') ? move.replace('\'', '') : move + '\'';
                }
                return move;
            });
            
            document.getElementById('scramble-info').innerHTML = 
                `scramble: ${displayScramble.join(' ')}<br>` +
                `è§£æ³•: ${displaySolution.join(' ')}`;
        }
        
        function isOppositeAxisPattern(currentMove, sequence) {
            // R L R ã‚„ U D U ã®ã‚ˆã†ãªå¯¾é¢è»¸ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ¤œå‡º
            if (sequence.length < 2) return false;
            
            const current = currentMove.replace('\'', '').replace('2', '').replace('w', '');
            const prev1 = sequence[sequence.length - 1].replace('\'', '').replace('2', '').replace('w', '');
            const prev2 = sequence[sequence.length - 2].replace('\'', '').replace('2', '').replace('w', '');
            
            // å¯¾é¢è»¸ã®ãƒšã‚¢ã‚’å®šç¾©
            const oppositePairs = [
                ['R', 'L'],
                ['U', 'D'],
                ['F', 'B']
            ];
            
            // ç¾åœ¨ã®æ‰‹é †ãŒ2æ‰‹å‰ã¨åŒã˜ã§ã€1æ‰‹å‰ãŒå¯¾é¢è»¸ã‹ãƒã‚§ãƒƒã‚¯
            if (current === prev2) {
                for (const pair of oppositePairs) {
                    if ((pair[0] === current && pair[1] === prev1) ||
                        (pair[1] === current && pair[0] === prev1)) {
                        return true; // R L R ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ¤œå‡º
                    }
                }
            }
            
            return false;
        }

        function isSameAxis(move1, move2) {
            // åŒã˜è»¸ã®å›è»¢ã‹ã©ã†ã‹ã‚’åˆ¤å®š
            const base1 = move1.replace('\'', '').replace('2', '').replace('w', '');
            const base2 = move2.replace('\'', '').replace('2', '').replace('w', '');
            
            // åŸºæœ¬çš„ã«åŒã˜è»¸ã®å ´åˆ
            if (base1 === base2) {
                return true;
            }
            
            // Uwç³»ã¨U/Dç³»ã®ç‰¹åˆ¥åˆ¤å®š
            const isUw1 = move1.includes('Uw');
            const isUw2 = move2.includes('Uw');
            const isU1 = base1 === 'U';
            const isU2 = base2 === 'U';
            const isD1 = base1 === 'D';
            const isD2 = base2 === 'D';
            
            // Uwç³»ã¨Uç³»ã¯åŒã˜è»¸ã¨ã—ã¦æ‰±ã†
            if ((isUw1 && isU2) || (isU1 && isUw2)) {
                return true;
            }
            
            // Uwç³»ã¨Dç³»ã¯é€£ç¶šã—ãªã„ã‚ˆã†ã«ã™ã‚‹
            if ((isUw1 && isD2) || (isD1 && isUw2)) {
                return true;
            }
            
            return false;
        }
        
        function resetToScrambled() {
            if (!scrambledState) {
                return; // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤ºã›ãšã«ä½•ã‚‚ã—ãªã„
            }
            
            // 5æ‰‹å´©ã—ãŸçŠ¶æ…‹ã«æˆ»ã™
            cubeGroup.children.forEach((cube, index) => {
                cube.position.copy(scrambledState[index].position);
                cube.quaternion.copy(scrambledState[index].quaternion);
            });
            
            // æ‰‹æ•°ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã‚’ãƒªã‚»ãƒƒãƒˆ
            moveCount = 0;
            isGameMode = true;
            updateGameInfo();
        }
        
        function isOppositeMove(move1, move2) {
            const base1 = move1.replace('\'', '');
            const base2 = move2.replace('\'', '');
            return base1 === base2;
        }
        
        function getInverseMove(move) {
            // 180åº¦å›è»¢ã®å ´åˆã¯åŒã˜æ‰‹é †
            if (move.includes('2')) {
                return move;
            }
            
            // R, U, Fï¼ˆãŠã‚ˆã³Uwï¼‰ã¯è¡¨ç¤ºä¸Šé€†ã«ã™ã‚‹å¿…è¦ãŒã‚ã‚‹
            const base = move.replace('\'', '').replace('w', '');
            if (base === 'R' || base === 'U' || base === 'F') {
                return move.includes('\'') ? move.replace('\'', '') : move + '\'';
            } else {
                return move.includes('\'') ? move.replace('\'', '') : move + '\'';
            }
        }
        
        function executeMove(move, animate = true) {
            // å®Ÿéš›ã®å›è»¢ã‚’å®Ÿè¡Œï¼ˆç°¡ç•¥åŒ–ç‰ˆï¼‰
            let angle = Math.PI / 2;
            
            // 180åº¦å›è»¢ã®å ´åˆ
            if (move.includes('2')) {
                angle = Math.PI;
            }
            
            const rotationAxis = getRotationAxis(move);
            let direction = 1;
            
            // R, U, F, Uwã®å›è»¢æ–¹å‘ã‚’ä¿®æ­£
            const base = move.replace('\'', '').replace('2', '').replace('w', '');
            if (base === 'R' || base === 'U' || base === 'F') {
                direction = 1; // æ­£æ–¹å‘ã«å¤‰æ›´
            }
            
            // é€†å›è»¢ã®å ´åˆ
            if (move.includes('\'')) {
                direction = -direction;
            }
            // 180åº¦å›è»¢ã®å ´åˆã¯æ–¹å‘ã¯é–¢ä¿‚ãªã„
            else if (move.includes('2')) {
                direction = Math.abs(direction);
            }
            
            // è©²å½“ã™ã‚‹é¢ã®ã‚­ãƒ¥ãƒ¼ãƒ–ã‚’é¸æŠã—ã¦å›è»¢
            const cubesToRotate = selectCubesToRotate(move);
            cubesToRotate.forEach(cube => {
                const quaternion = new THREE.Quaternion().setFromAxisAngle(rotationAxis, angle * direction);
                cube.position.applyQuaternion(quaternion);
                cube.quaternion.multiplyQuaternions(quaternion, cube.quaternion);
            });
        }
        
        function getRotationAxis(move) {
            const base = move.replace('\'', '').replace('2', '').replace('w', '');
            switch(base) {
                case 'R': case 'L': return new THREE.Vector3(1, 0, 0);
                case 'U': case 'D': return new THREE.Vector3(0, 1, 0);
                case 'F': case 'B': return new THREE.Vector3(0, 0, 1);
                default: return new THREE.Vector3(0, 1, 0);
            }
        }
        
        function selectCubesToRotate(move) {
            return cubeGroup.children.filter((cube, index) => {
                const pos = cube.position;
                const base = move.replace('\'', '').replace('2', '');
                
                // Uwã®å ´åˆã¯ä¸Šé¢2å±¤ã‚’å›è»¢
                if (base === 'Uw') {
                    return pos.y >= -0.5; // ä¸­æ®µã¨ä¸Šæ®µ
                }
                
                const cleanBase = base.replace('w', '');
                switch(cleanBase) {
                    case 'R': return pos.x > 0.5;
                    case 'L': return pos.x < -0.5;
                    case 'U': return pos.y > 0.5;
                    case 'D': return pos.y < -0.5;
                    case 'F': return pos.z > 0.5;
                    case 'B': return pos.z < -0.5;
                    default: return false;
                }
            });
        }
        
        function executeYRotation(move) {
            // ã‚­ãƒ¥ãƒ¼ãƒ–å…¨ä½“ã‚’yè»¸å›è»¢ï¼ˆæŒã¡æ›¿ãˆï¼‰
            const angle = Math.PI / 2;
            const direction = move.includes('\'') ? 1 : -1; // yã®æ–¹å‘ã‚’èª¿æ•´
            
            cubeGroup.children.forEach(cube => {
                // å„ã‚­ãƒ¥ãƒ¼ãƒ–ã®ä½ç½®ã‚’yè»¸ä¸­å¿ƒã«å›è»¢
                const pos = cube.position.clone();
                const newX = pos.z * direction;
                const newZ = -pos.x * direction;
                cube.position.set(newX, pos.y, newZ);
                
                // å„ã‚­ãƒ¥ãƒ¼ãƒ–è‡ªä½“ã‚‚yè»¸å›è»¢
                const quaternion = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), angle * direction);
                cube.quaternion.multiplyQuaternions(quaternion, cube.quaternion);
            });
        }
        
        function updateGameInfo() {
            document.getElementById('move-counter').textContent = `æ‰‹æ•°: ${moveCount}`;
        }
        
        function checkSolved() {
            if (!isGameMode) return;
            
            const isSolved = isInSolvedState();
            if (isSolved) {
                isGameMode = false;
                updateGameInfo();
                // å®Œæˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å‰Šé™¤
            }
        }
        
        function isInSolvedState() {
            // X-crosså®ŒæˆçŠ¶æ…‹ã®åˆ¤å®š
            // å„ã‚­ãƒ¥ãƒ¼ãƒ–ãŒæ­£ã—ã„ä½ç½®ã¨å‘ãã«ã‚ã‚‹ã‹ã‚’ãƒã‚§ãƒƒã‚¯
            
            let solvedCount = 0;
            const totalCubes = cubeGroup.children.length;
            
            cubeGroup.children.forEach((cube, index) => {
                const x = index % 3;
                const y = Math.floor((index % 9) / 3);
                const z = Math.floor(index / 9);
                
                const expectedPos = new THREE.Vector3(
                    (x - 1) * 0.95,
                    (y - 1) * 0.95,
                    (z - 1) * 0.95
                );
                
                // ä½ç½®ã®è¨±å®¹èª¤å·®
                const positionTolerance = 0.1;
                const isInCorrectPosition = cube.position.distanceTo(expectedPos) < positionTolerance;
                
                // å›è»¢ã®è¨±å®¹èª¤å·®ï¼ˆå››å…ƒæ•°ã§åˆ¤å®šï¼‰
                const expectedQuat = new THREE.Quaternion(0, 0, 0, 1);
                const rotationTolerance = 0.1;
                const isInCorrectRotation = Math.abs(cube.quaternion.w - expectedQuat.w) < rotationTolerance &&
                                          Math.abs(cube.quaternion.x - expectedQuat.x) < rotationTolerance &&
                                          Math.abs(cube.quaternion.y - expectedQuat.y) < rotationTolerance &&
                                          Math.abs(cube.quaternion.z - expectedQuat.z) < rotationTolerance;
                
                if (isInCorrectPosition && isInCorrectRotation) {
                    solvedCount++;
                }
            });
            
            // 80%ä»¥ä¸Šã®ã‚­ãƒ¥ãƒ¼ãƒ–ãŒæ­£ã—ã„ä½ç½®ã«ã‚ã‚Œã°å®Œæˆã¨ã¿ãªã™ï¼ˆç°¡ç•¥åŒ–ã•ã‚ŒãŸåˆ¤å®šï¼‰
            return solvedCount >= totalCubes * 0.8;
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

            // åˆæœŸåŒ–å®Ÿè¡Œ
            init();
            updateGameInfo();
    </script>
</body>
</html>
