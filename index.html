<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>プ口ジェクトＸ</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.0/font/bootstrap-icons.css" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 16px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.3);
            padding: 8px 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            cursor: pointer;
            transition: background 0.3s ease;
        }
        
        #info:hover {
            background: rgba(0, 0, 0, 0.4);
        }
        
        #info h3 {
            margin: 0;
        }
        
        #modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            display: none;
            justify-content: center;
            align-items: center;
        }
        
        #modal-content {
            background: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 15px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            color: #333;
        }
        
        #modal-content h2 {
            margin-top: 0;
            color: #4a5568;
            text-align: center;
            border-bottom: 2px solid #e2e8f0;
            padding-bottom: 10px;
        }
        
        #modal-content h3 {
            color: #2d3748;
            margin-top: 20px;
            margin-bottom: 10px;
        }
        
        #modal-content ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        
        #modal-content li {
            margin: 5px 0;
            line-height: 1.4;
        }
        
        .close-button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 20px;
            display: block;
            margin-left: auto;
            margin-right: auto;
        }
        
        .close-button:hover {
            background: #5a67d8;
        }
        
        #input-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            display: none;
            justify-content: center;
            align-items: center;
        }
        
        #input-modal-content {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            max-width: 90vw;
            width: 400px;
            max-height: 80vh;
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            color: #333;
            box-sizing: border-box;
        }
        
        #input-modal-content h2 {
            margin-top: 0;
            color: #4a5568;
            text-align: center;
            border-bottom: 2px solid #e2e8f0;
            padding-bottom: 10px;
        }
        
        #move-input {
            width: 100%;
            padding: 15px;
            font-size: 16px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            margin: 15px 0;
            font-family: monospace;
            box-sizing: border-box;
            resize: none;
            background-color: #f8f9fa;
            cursor: default;
        }
        
        #move-input:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .input-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }
        
        .input-button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
        }
        
        .go-button {
            background: #48bb78;
            color: white;
        }
        
        .go-button:hover {
            background: #38a169;
        }
        
        .cancel-button {
            background: #e53e3e;
            color: white;
        }
        
        .cancel-button:hover {
            background: #c53030;
        }
        
        .notation-buttons {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 8px;
            margin: 15px 0;
        }
        
        .notation-button {
            padding: 8px 4px;
            border: 1px solid #cbd5e0;
            border-radius: 6px;
            background: #f7fafc;
            color: #2d3748;
            cursor: pointer;
            font-size: 14px;
            font-family: monospace;
            transition: all 0.2s ease;
        }
        
        .notation-button:hover {
            background: #e2e8f0;
            border-color: #a0aec0;
        }
        
        .notation-button:active {
            background: #cbd5e0;
        }
        
        #controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 100;
        }
        
        button {
            padding: 12px 20px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 50px;
            min-height: 50px;
        }
        
        button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }
        
        button:active {
            transform: translateY(0);
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="info" onclick="showControls()">
            <h3>プロジェクトX</h3>
        </div>
        <div id="reset-controls" style="position: absolute; top: 70px; left: 20px; z-index: 100; background: rgba(0, 0, 0, 0.3); padding: 10px; border-radius: 10px; backdrop-filter: blur(10px);">
            <div style="color: white; font-size: 14px; margin-bottom: 8px; text-align: left;">リセット</div>
            <div style="display: flex; gap: 10px;">
                <button onclick="resetToScrambled()" title="スクランブルリセット">
                    <img src="https://img.icons8.com/?size=20&id=37981&format=png&color=ffffff" alt="reset" style="width: 20px; height: 20px;">
                </button>
                <button onclick="resetCamera()" title="カメラリセット"><i class="bi bi-camera-fill"></i></button>
            </div>
        </div>
        <div id="controls">
            <select id="scramble-length" style="padding: 12px; background: rgba(255, 255, 255, 0.2); border: 2px solid rgba(255, 255, 255, 0.3); color: white; border-radius: 8px; cursor: pointer; font-size: 14px; backdrop-filter: blur(10px); margin-right: 10px;">
                <option value="1" style="background: #333; color: white;">1手</option>
                <option value="2" style="background: #333; color: white;">2手</option>
                <option value="3" style="background: #333; color: white;">3手</option>
                <option value="4" style="background: #333; color: white;">4手</option>
                <option value="5" style="background: #333; color: white;" selected>5手</option>
                <option value="6" style="background: #333; color: white;">6手</option>
                <option value="7" style="background: #333; color: white;">7手</option>
                <option value="8" style="background: #333; color: white;">8手</option>
                <option value="9" style="background: #333; color: white;">9手</option>
                <option value="10" style="background: #333; color: white;">10手</option>
                <option value="11" style="background: #333; color: white;">11手</option>
                <option value="12" style="background: #333; color: white;">12手</option>
            </select>
            <select id="scramble-type" style="padding: 12px; background: rgba(255, 255, 255, 0.2); border: 2px solid rgba(255, 255, 255, 0.3); color: white; border-radius: 8px; cursor: pointer; font-size: 14px; backdrop-filter: blur(10px); margin-right: 10px;">
                <option value="exact" style="background: #333; color: white;" selected>固定</option>
                <option value="within" style="background: #333; color: white;">以内</option>
            </select>
            <button onclick="scrambleWithSelectedLength()" style="padding: 12px 20px; background: rgba(255, 255, 255, 0.2); border: 2px solid rgba(255, 255, 255, 0.3); color: white; border-radius: 8px; cursor: pointer; font-size: 14px; transition: all 0.3s ease; backdrop-filter: blur(10px);" onmouseover="this.style.background='rgba(255, 255, 255, 0.3)'; this.style.transform='translateY(-2px)'" onmouseout="this.style.background='rgba(255, 255, 255, 0.2)'; this.style.transform='translateY(0)'">崩す</button>
            <button onclick="solveCube()" style="padding: 12px 20px; background: rgba(255, 255, 255, 0.2); border: 2px solid rgba(255, 255, 255, 0.3); color: white; border-radius: 8px; cursor: pointer; font-size: 14px; transition: all 0.3s ease; backdrop-filter: blur(10px);" onmouseover="this.style.background='rgba(255, 255, 255, 0.3)'; this.style.transform='translateY(-2px)'" onmouseout="this.style.background='rgba(255, 255, 255, 0.2)'; this.style.transform='translateY(0)'">揃える</button>
        </div>
        <div id="game-info" style="position: absolute; top: 20px; right: 20px; color: white; background: rgba(0, 0, 0, 0.3); padding: 15px; border-radius: 10px; backdrop-filter: blur(10px);">
            <div id="move-counter">手数: 0</div>
            <div id="scramble-info"></div>
        </div>
        
        <!-- 操作方法ポップアップ -->
        <div id="modal-overlay" onclick="hideControls()">
            <div id="modal-content" onclick="event.stopPropagation()">
                <h2>📋 操作方法</h2>
                
                <h3>🖱️ マウス操作</h3>
                <ul>
                    <li><strong>ドラッグ</strong>：キューブを自由に回転</li>
                    <li><strong>ホイール</strong>：ズームイン・ズームアウト</li>
                </ul>
                
                <h3>⌨️ キーボード操作（ゲーム中のみ）</h3>
                <ul>
                    <li><strong>R, L, U, D, F, B</strong>：各面の回転</li>
                    <li><strong>Shift + R, L, U, D, F, B</strong>：各面の逆回転</li>
                    <li><strong>Ctrl/Cmd + R, L, U, D, F, B</strong>：各面の180度回転</li>
                    <li><strong>Alt + U</strong>：Uw（上面ワイド回転）</li>
                    <li><strong>Alt + Shift + U</strong>：Uw'（上面ワイド回転 逆）</li>
                    <li><strong>y</strong>：キューブ全体のy軸回転（持ち替え）</li>
                    <li><strong>Shift + y</strong>：キューブ全体のy軸逆回転</li>
                </ul>
                
                <h3>🎮 ゲームの流れ</h3>
                <ul>
                    <li><strong>手数とタイプを選択</strong>：1-12手、固定/以内を選択</li>
                    <li><strong>「崩す」</strong>：X-cross完成状態から指定条件でスクランブル</li>
                    <li><strong>キーボード操作</strong>：X-cross完成状態に戻す</li>
                    <li><strong>「揃える」</strong>：回転記号をボタンで入力して実行</li>
                    <li><strong>リセット機能</strong>：🔗でスクランブル状態に戻す、📷でカメラ位置リセット</li>
                </ul>
                
                <h3>🔧 その他の機能</h3>
                <ul>
                    <li><strong>回転記号入力</strong>：「揃える」ボタンで入力画面を開く</li>
                    <li><strong>入力方法</strong>：ボタンクリックのみ（キーボード入力無効）</li>
                    <li><strong>対応記号</strong>：R, L, U, D, F, B（', 2付き）、Uw, Uw', y, y'</li>
                    <li><strong>編集機能</strong>：←で取消、クリアで全削除</li>
                </ul>
                
                <h3>📱 タッチ操作</h3>
                <ul>
                    <li><strong>タッチ&ドラッグ</strong>：キューブを回転</li>
                    <li><strong>ピンチ</strong>：ズーム（一部デバイス）</li>
                </ul>
                
                <button class="close-button" onclick="hideControls()">閉じる</button>
            </div>
        </div>
        
        <!-- 回転入力ポップアップ -->
        <div id="input-modal-overlay" onclick="hideInputModal()">
            <div id="input-modal-content" onclick="event.stopPropagation()">
                <textarea id="move-input" placeholder="回転記号ボタンで入力してください" rows="4" readonly></textarea>
                
                <div class="notation-buttons">
                    <button class="notation-button" onclick="addNotation('R')">R</button>
                    <button class="notation-button" onclick="addNotation('R\'')">R'</button>
                    <button class="notation-button" onclick="addNotation('R2')">R2</button>
                    <button class="notation-button" onclick="addNotation('L')">L</button>
                    <button class="notation-button" onclick="addNotation('L\'')">L'</button>
                    <button class="notation-button" onclick="addNotation('L2')">L2</button>
                    
                    <button class="notation-button" onclick="addNotation('U')">U</button>
                    <button class="notation-button" onclick="addNotation('U\'')">U'</button>
                    <button class="notation-button" onclick="addNotation('U2')">U2</button>
                    <button class="notation-button" onclick="addNotation('D')">D</button>
                    <button class="notation-button" onclick="addNotation('D\'')">D'</button>
                    <button class="notation-button" onclick="addNotation('D2')">D2</button>
                    
                    <button class="notation-button" onclick="addNotation('F')">F</button>
                    <button class="notation-button" onclick="addNotation('F\'')">F'</button>
                    <button class="notation-button" onclick="addNotation('F2')">F2</button>
                    <button class="notation-button" onclick="addNotation('B')">B</button>
                    <button class="notation-button" onclick="addNotation('B\'')">B'</button>
                    <button class="notation-button" onclick="addNotation('B2')">B2</button>
                    
                    <button class="notation-button" onclick="addNotation('Uw')">Uw</button>
                    <button class="notation-button" onclick="addNotation('Uw\'')">Uw'</button>
                    <button class="notation-button" onclick="addNotation('y')">y</button>
                    <button class="notation-button" onclick="addNotation('y\'')">y'</button>
                    <button class="notation-button" onclick="undoLastMove()">←</button>
                    <button class="notation-button" onclick="clearInput()">クリア</button>
                </div>
                
                <div class="input-buttons">
                    <button class="input-button go-button" onclick="executeInputMoves()">Go!</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, cube, cubeGroup;
        let mouseX = 0, mouseY = 0;
        let isMouseDown = false;
        let moveCount = 0;
        let isGameMode = false;
        let scrambleSequence = [];
        let solutionSequence = [];
        let cubeState = []; // キューブの状態を保存
        
        // 回転の定義
        const moves = ['R', 'R\'', 'R2', 'L', 'L\'', 'L2', 'U', 'U\'', 'U2', 'Uw', 'Uw\'', 'D', 'D\'', 'D2', 'F', 'F\'', 'F2', 'B', 'B\'', 'B2'];
        
        // 完成状態の定義
        const solvedState = {
            centers: true,
            whiteEdges: true,
            blueOrangeF2L: true
        };
        
        // ルービックキューブの色定義
        const colors = {
            front: 0xff0000,   // 赤
            back: 0xff8c00,    // オレンジ  
            right: 0x00ff00,   // 緑
            left: 0x0000ff,    // 青
            top: 0xffffff,     // 白
            bottom: 0xffff00   // 黄
        };

        function init() {
            // シーン作成
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);

            // カメラ作成
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(4, 3, 6);
            camera.lookAt(0, 0, 0);

            // レンダラー作成
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);

            // ライティング
            const ambientLight = new THREE.AmbientLight(0x404040, 1.0); // アンビエントライトを強化
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6); // ディレクショナルライトを弱化
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // 追加の補助ライト（影を軽減）
            const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
            fillLight.position.set(-10, -10, -5); // 反対方向から照射
            scene.add(fillLight);

            // ルービックキューブ作成
            createRubiksCube();

            // イベントリスナー
            setupEventListeners();

            // アニメーションループ開始
            animate();
        }

        function createRubiksCube() {
            cubeGroup = new THREE.Group();
            
            const cubeSize = 0.9;
            const gap = 0.05;
            const totalSize = cubeSize + gap;

            for (let x = 0; x < 3; x++) {
                for (let y = 0; y < 3; y++) {
                    for (let z = 0; z < 3; z++) {
                        // センターパーツかどうかを判定
                        const isCenter = (x === 1 && y === 1) || (x === 1 && z === 1) || (y === 1 && z === 1);
                        
                        // 白色のエッジパーツかどうかを判定（底面の十字）
                        const isWhiteEdge = (y === 0) && // 底面にある
                                          ((x === 1 && z !== 1) || (z === 1 && x !== 1)); // エッジの位置
                        
                        // 青とオレンジのF2Lペア（左側面-背面のコーナー）かどうかを判定
                        const isBlueOrangeF2L = (x === 0 && z === 0) && (y === 0 || y === 1); // 左後のコーナーとエッジ（青は左側面、オレンジは背面）
                        
                        const smallCube = createSmallCube(cubeSize, isCenter, isWhiteEdge, isBlueOrangeF2L);
                        smallCube.position.set(
                            (x - 1) * totalSize,
                            (y - 1) * totalSize,
                            (z - 1) * totalSize
                        );
                        cubeGroup.add(smallCube);
                    }
                }
            }

            scene.add(cubeGroup);
        }

        function createSmallCube(size, isCenter = false, isWhiteEdge = false, isBlueOrangeF2L = false) {
            const geometry = new THREE.BoxGeometry(size, size, size);
            
            let materials;
            
            if (isCenter || isWhiteEdge || isBlueOrangeF2L) {
                // センターパーツ、白色エッジパーツ、または青オレンジF2Lペアは元の色を維持
                materials = [
                    new THREE.MeshLambertMaterial({ color: colors.right }),  // 右（緑）
                    new THREE.MeshLambertMaterial({ color: colors.left }),   // 左（青）
                    new THREE.MeshLambertMaterial({ color: colors.bottom }), // 上（黄）
                    new THREE.MeshLambertMaterial({ color: colors.top }),    // 下（白）
                    new THREE.MeshLambertMaterial({ color: colors.front }),  // 前（赤）
                    new THREE.MeshLambertMaterial({ color: colors.back })    // 後（オレンジ）
                ];
            } else {
                // その他のパーツ（F2Lペアを含む）はすべてグレー
                const grayMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
                materials = [grayMaterial, grayMaterial, grayMaterial, grayMaterial, grayMaterial, grayMaterial];
            }

            const cube = new THREE.Mesh(geometry, materials);
            cube.castShadow = true;
            cube.receiveShadow = true;

            // エッジを追加してよりリアルに
            const edges = new THREE.EdgesGeometry(geometry);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 }));
            cube.add(line);

            return cube;
        }

        function setupEventListeners() {
            // マウスイベント
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('wheel', onWheel);

            // タッチイベント
            renderer.domElement.addEventListener('touchstart', onTouchStart);
            renderer.domElement.addEventListener('touchmove', onTouchMove);
            renderer.domElement.addEventListener('touchend', onTouchEnd);

            // キーボードイベント（回転操作用）
            window.addEventListener('keydown', onKeyDown);
            
            // リサイズイベント
            window.addEventListener('resize', onWindowResize);
        }

        function onKeyDown(event) {
            if (!isGameMode) return;
            
            const key = event.key.toLowerCase();
            let move = '';
            
            switch(key) {
                case 'r': 
                    if (event.ctrlKey || event.metaKey) {
                        move = 'R2';
                    } else {
                        move = event.shiftKey ? 'R' : 'R\'';
                    }
                    break;
                case 'l': 
                    if (event.ctrlKey || event.metaKey) {
                        move = 'L2';
                    } else {
                        move = event.shiftKey ? 'L\'' : 'L';
                    }
                    break;
                case 'u': 
                    if (event.altKey) {
                        // Alt + U で Uw（ワイド回転）
                        move = event.shiftKey ? 'Uw' : 'Uw\'';
                    } else if (event.ctrlKey || event.metaKey) {
                        move = 'U2';
                    } else {
                        move = event.shiftKey ? 'U' : 'U\'';
                    }
                    break;
                case 'd': 
                    if (event.ctrlKey || event.metaKey) {
                        move = 'D2';
                    } else {
                        move = event.shiftKey ? 'D\'' : 'D';
                    }
                    break;
                case 'f': 
                    if (event.ctrlKey || event.metaKey) {
                        move = 'F2';
                    } else {
                        move = event.shiftKey ? 'F' : 'F\'';
                    }
                    break;
                case 'b': 
                    if (event.ctrlKey || event.metaKey) {
                        move = 'B2';
                    } else {
                        move = event.shiftKey ? 'B\'' : 'B';
                    }
                    break;
                case 'y': move = event.shiftKey ? 'y\'' : 'y'; break;
            }
            
            if (move) {
                if (move === 'y' || move === 'y\'') {
                    executeYRotation(move);
                } else {
                    executeMove(move);
                    moveCount++;
                }
                updateGameInfo();
                checkSolved();
            }
        }

        function onMouseDown(event) {
            isMouseDown = true;
            mouseX = event.clientX;
            mouseY = event.clientY;
        }

        function onMouseMove(event) {
            if (!isMouseDown) return;

            const deltaX = event.clientX - mouseX;
            const deltaY = event.clientY - mouseY;

            cubeGroup.rotation.y += deltaX * 0.01;
            cubeGroup.rotation.x += deltaY * 0.01;

            mouseX = event.clientX;
            mouseY = event.clientY;
        }

        function onMouseUp(event) {
            isMouseDown = false;
        }

        function onWheel(event) {
            camera.position.multiplyScalar(event.deltaY > 0 ? 1.1 : 0.9);
            camera.position.clampLength(3, 20);
        }

        function onTouchStart(event) {
            if (event.touches.length === 1) {
                mouseX = event.touches[0].clientX;
                mouseY = event.touches[0].clientY;
                isMouseDown = true;
            }
        }

        function onTouchMove(event) {
            event.preventDefault();
            if (event.touches.length === 1 && isMouseDown) {
                const deltaX = event.touches[0].clientX - mouseX;
                const deltaY = event.touches[0].clientY - mouseY;

                cubeGroup.rotation.y += deltaX * 0.01;
                cubeGroup.rotation.x += deltaY * 0.01;

                mouseX = event.touches[0].clientX;
                mouseY = event.touches[0].clientY;
            }
        }

        function onTouchEnd(event) {
            isMouseDown = false;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function scrambleCube() {
            cubeGroup.children.forEach(cube => {
                // ランダムな位置に移動
                cube.position.add(new THREE.Vector3(
                    (Math.random() - 0.5) * 0.2,
                    (Math.random() - 0.5) * 0.2,
                    (Math.random() - 0.5) * 0.2
                ));
                
                // ランダムな回転
                cube.rotation.set(
                    Math.random() * Math.PI * 2,
                    Math.random() * Math.PI * 2,
                    Math.random() * Math.PI * 2
                );
            });
        }

        function solveCube() {
            showInputModal();
        }
        
        function showInputModal() {
            document.getElementById('input-modal-overlay').style.display = 'flex';
            document.getElementById('move-input').focus();
        }
        
        function hideInputModal() {
            document.getElementById('input-modal-overlay').style.display = 'none';
            document.getElementById('move-input').value = '';
        }
        
        function addNotation(notation) {
            const input = document.getElementById('move-input');
            if (input.value && !input.value.endsWith(' ')) {
                input.value += ' ';
            }
            input.value += notation;
        }
        
        function clearInput() {
            document.getElementById('move-input').value = '';
        }
        
        function undoLastMove() {
            const input = document.getElementById('move-input');
            const moves = input.value.trim().split(/\s+/);
            if (moves.length > 0 && moves[0] !== '') {
                moves.pop();
                input.value = moves.join(' ');
                if (input.value.length > 0) {
                    input.value += ' ';
                }
            }
        }

        function executeInputMoves() {
            const input = document.getElementById('move-input').value.trim();
            if (!input) {
                alert('回転記号を入力してください。');
                return;
            }
            
            // 入力された手順を解析
            const moves = input.split(/\s+/).filter(move => move.length > 0);
            
            // 有効な手順かチェック
            const validMoves = ['R', 'R\'', 'R2', 'L', 'L\'', 'L2', 'U', 'U\'', 'U2', 'Uw', 'Uw\'', 'D', 'D\'', 'D2', 'F', 'F\'', 'F2', 'B', 'B\'', 'B2', 'y', 'y\''];
            const invalidMoves = moves.filter(move => !validMoves.includes(move));
            
            if (invalidMoves.length > 0) {
                alert(`無効な回転記号が含まれています: ${invalidMoves.join(', ')}`);
                return;
            }
            
            hideInputModal();
            
            // 入力された手順を実行用に変換（R, U, F, Uwの回転を逆に変換）
            const convertedMoves = moves.map(move => {
                if (move.includes('2')) {
                    return move; // 180度回転はそのまま
                }
                const base = move.replace('\'', '').replace('w', '');
                if (base === 'R' || base === 'U' || base === 'F') {
                    return move.includes('\'') ? move.replace('\'', '') : move + '\'';
                }
                return move;
            });
            
            // 手順を順次実行
            convertedMoves.forEach((move, index) => {
                setTimeout(() => {
                    if (move === 'y' || move === 'y\'') {
                        executeYRotation(move);
                    } else {
                        executeMove(move);
                        if (isGameMode) {
                            moveCount++;
                            updateGameInfo();
                        }
                    }
                    
                    // 最後の手順の後に完成チェック
                    if (index === convertedMoves.length - 1 && isGameMode) {
                        setTimeout(() => {
                            checkSolved();
                        }, 100);
                    }
                }, index * 300); // 300ms間隔で実行
            });
        }

        function showControls() {
            document.getElementById('modal-overlay').style.display = 'flex';
        }
        
        function hideControls() {
            document.getElementById('modal-overlay').style.display = 'none';
        }

        function resetCamera() {
            // カメラを初期位置に戻す
            camera.position.set(4, 3, 6);
            camera.lookAt(0, 0, 0);
            camera.up.set(0, 1, 0); // カメラの上方向をリセット
            camera.updateProjectionMatrix();
            camera.updateMatrixWorld();
            
            // キューブの回転もリセット
            cubeGroup.rotation.set(0, 0, 0);
        }

        function resetCube() {
            cubeGroup.children.forEach((cube, index) => {
                const x = index % 3;
                const y = Math.floor((index % 9) / 3);
                const z = Math.floor(index / 9);
                
                const cubeSize = 0.9;
                const gap = 0.05;
                const totalSize = cubeSize + gap;
                
                // 位置をリセット
                cube.position.set(
                    (x - 1) * totalSize,
                    (y - 1) * totalSize,
                    (z - 1) * totalSize
                );
                
                // 回転をリセット
                cube.rotation.set(0, 0, 0);
                cube.quaternion.set(0, 0, 0, 1);
            });
            
            // ゲーム状態をリセット
            moveCount = 0;
            isGameMode = false;
            scrambleSequence = [];
            solutionSequence = [];
            updateGameInfo();
            document.getElementById('scramble-info').innerHTML = '';
        }

        let scrambledState = null; // 5手崩した状態を保存

        function scrambleWithSelectedLength() {
            const lengthSelect = document.getElementById('scramble-length');
            const typeSelect = document.getElementById('scramble-type');
            const maxMoves = parseInt(lengthSelect.value);
            const isExact = typeSelect.value === 'exact';
            
            let numMoves;
            if (isExact) {
                // ちょうどn手
                numMoves = maxMoves;
            } else {
                // n手以内（1手からn手のランダム）
                numMoves = Math.floor(Math.random() * maxMoves) + 1;
            }
            
            scrambleFromSolved(numMoves);
        }

        function scrambleFromSolved(numMoves) {
            resetCube();
            scrambleSequence = [];
            solutionSequence = [];
            
            // ランダムな手順を生成
            for (let i = 0; i < numMoves; i++) {
                let randomMove;
                do {
                    randomMove = moves[Math.floor(Math.random() * moves.length)];
                    
                } while (
                    // 最初の手順でU系を避ける
                    (i === 0 && randomMove.replace('\'', '').replace('2', '').replace('w', '') === 'U') ||
                    
                    // 2手目で特別な条件をチェック（1手目がD系の場合、2手目はU系を避ける）
                    (i === 1 && scrambleSequence.length > 0 && 
                     scrambleSequence[0].replace('\'', '').replace('2', '').replace('w', '') === 'D' &&
                     randomMove.replace('\'', '').replace('2', '').replace('w', '') === 'U') ||
                    
                    // 連続同軸回避
                    (scrambleSequence.length > 0 && isSameAxis(randomMove, scrambleSequence[scrambleSequence.length - 1])) ||
                    
                    // 対面軸パターン回避
                    (scrambleSequence.length >= 2 && isOppositeAxisPattern(randomMove, scrambleSequence))
                );
                
                scrambleSequence.push(randomMove);
                // 解法は逆順で逆の手順
                solutionSequence.unshift(getInverseMove(randomMove));
            }
            
            // スクランブルを実行（視覚的には見せない）
            scrambleSequence.forEach(move => {
                executeMove(move, false);
            });
            
            // 崩した状態を保存
            scrambledState = cubeGroup.children.map(cube => ({
                position: cube.position.clone(),
                quaternion: cube.quaternion.clone()
            }));
            
            // ゲームモード開始
            moveCount = 0;
            isGameMode = true;
            updateGameInfo();
            
            // 表示用のスクランブルと解法を修正（R, U, F, Uwの回転を逆に表示）
            const displayScramble = scrambleSequence.map(move => {
                if (move.includes('2')) {
                    return move; // 180度回転はそのまま
                }
                const base = move.replace('\'', '').replace('w', '');
                if (base === 'R' || base === 'U' || base === 'F') {
                    return move.includes('\'') ? move.replace('\'', '') : move + '\'';
                }
                return move;
            });
            
            const displaySolution = solutionSequence.map(move => {
                if (move.includes('2')) {
                    return move; // 180度回転はそのまま
                }
                const base = move.replace('\'', '').replace('w', '');
                if (base === 'R' || base === 'U' || base === 'F') {
                    return move.includes('\'') ? move.replace('\'', '') : move + '\'';
                }
                return move;
            });
            
            document.getElementById('scramble-info').innerHTML = 
                `scramble: ${displayScramble.join(' ')}<br>` +
                `解法: ${displaySolution.join(' ')}`;
        }
        
        function isOppositeAxisPattern(currentMove, sequence) {
            // R L R や U D U のような対面軸パターンを検出
            if (sequence.length < 2) return false;
            
            const current = currentMove.replace('\'', '').replace('2', '').replace('w', '');
            const prev1 = sequence[sequence.length - 1].replace('\'', '').replace('2', '').replace('w', '');
            const prev2 = sequence[sequence.length - 2].replace('\'', '').replace('2', '').replace('w', '');
            
            // 対面軸のペアを定義
            const oppositePairs = [
                ['R', 'L'],
                ['U', 'D'],
                ['F', 'B']
            ];
            
            // 現在の手順が2手前と同じで、1手前が対面軸かチェック
            if (current === prev2) {
                for (const pair of oppositePairs) {
                    if ((pair[0] === current && pair[1] === prev1) ||
                        (pair[1] === current && pair[0] === prev1)) {
                        return true; // R L R パターンを検出
                    }
                }
            }
            
            return false;
        }

        function isSameAxis(move1, move2) {
            // 同じ軸の回転かどうかを判定
            const base1 = move1.replace('\'', '').replace('2', '').replace('w', '');
            const base2 = move2.replace('\'', '').replace('2', '').replace('w', '');
            
            // 基本的に同じ軸の場合
            if (base1 === base2) {
                return true;
            }
            
            // Uw系とU/D系の特別判定
            const isUw1 = move1.includes('Uw');
            const isUw2 = move2.includes('Uw');
            const isU1 = base1 === 'U';
            const isU2 = base2 === 'U';
            const isD1 = base1 === 'D';
            const isD2 = base2 === 'D';
            
            // Uw系とU系は同じ軸として扱う
            if ((isUw1 && isU2) || (isU1 && isUw2)) {
                return true;
            }
            
            // Uw系とD系は連続しないようにする
            if ((isUw1 && isD2) || (isD1 && isUw2)) {
                return true;
            }
            
            return false;
        }
        
        function resetToScrambled() {
            if (!scrambledState) {
                return; // メッセージを表示せずに何もしない
            }
            
            // 5手崩した状態に戻す
            cubeGroup.children.forEach((cube, index) => {
                cube.position.copy(scrambledState[index].position);
                cube.quaternion.copy(scrambledState[index].quaternion);
            });
            
            // 手数カウンターをリセット
            moveCount = 0;
            isGameMode = true;
            updateGameInfo();
        }
        
        function isOppositeMove(move1, move2) {
            const base1 = move1.replace('\'', '');
            const base2 = move2.replace('\'', '');
            return base1 === base2;
        }
        
        function getInverseMove(move) {
            // 180度回転の場合は同じ手順
            if (move.includes('2')) {
                return move;
            }
            
            // R, U, F（およびUw）は表示上逆にする必要がある
            const base = move.replace('\'', '').replace('w', '');
            if (base === 'R' || base === 'U' || base === 'F') {
                return move.includes('\'') ? move.replace('\'', '') : move + '\'';
            } else {
                return move.includes('\'') ? move.replace('\'', '') : move + '\'';
            }
        }
        
        function executeMove(move, animate = true) {
            // 実際の回転を実行（簡略化版）
            let angle = Math.PI / 2;
            
            // 180度回転の場合
            if (move.includes('2')) {
                angle = Math.PI;
            }
            
            const rotationAxis = getRotationAxis(move);
            let direction = 1;
            
            // R, U, F, Uwの回転方向を修正
            const base = move.replace('\'', '').replace('2', '').replace('w', '');
            if (base === 'R' || base === 'U' || base === 'F') {
                direction = 1; // 正方向に変更
            }
            
            // 逆回転の場合
            if (move.includes('\'')) {
                direction = -direction;
            }
            // 180度回転の場合は方向は関係ない
            else if (move.includes('2')) {
                direction = Math.abs(direction);
            }
            
            // 該当する面のキューブを選択して回転
            const cubesToRotate = selectCubesToRotate(move);
            cubesToRotate.forEach(cube => {
                const quaternion = new THREE.Quaternion().setFromAxisAngle(rotationAxis, angle * direction);
                cube.position.applyQuaternion(quaternion);
                cube.quaternion.multiplyQuaternions(quaternion, cube.quaternion);
            });
        }
        
        function getRotationAxis(move) {
            const base = move.replace('\'', '').replace('2', '').replace('w', '');
            switch(base) {
                case 'R': case 'L': return new THREE.Vector3(1, 0, 0);
                case 'U': case 'D': return new THREE.Vector3(0, 1, 0);
                case 'F': case 'B': return new THREE.Vector3(0, 0, 1);
                default: return new THREE.Vector3(0, 1, 0);
            }
        }
        
        function selectCubesToRotate(move) {
            return cubeGroup.children.filter((cube, index) => {
                const pos = cube.position;
                const base = move.replace('\'', '').replace('2', '');
                
                // Uwの場合は上面2層を回転
                if (base === 'Uw') {
                    return pos.y >= -0.5; // 中段と上段
                }
                
                const cleanBase = base.replace('w', '');
                switch(cleanBase) {
                    case 'R': return pos.x > 0.5;
                    case 'L': return pos.x < -0.5;
                    case 'U': return pos.y > 0.5;
                    case 'D': return pos.y < -0.5;
                    case 'F': return pos.z > 0.5;
                    case 'B': return pos.z < -0.5;
                    default: return false;
                }
            });
        }
        
        function executeYRotation(move) {
            // キューブ全体をy軸回転（持ち替え）
            const angle = Math.PI / 2;
            const direction = move.includes('\'') ? 1 : -1; // yの方向を調整
            
            cubeGroup.children.forEach(cube => {
                // 各キューブの位置をy軸中心に回転
                const pos = cube.position.clone();
                const newX = pos.z * direction;
                const newZ = -pos.x * direction;
                cube.position.set(newX, pos.y, newZ);
                
                // 各キューブ自体もy軸回転
                const quaternion = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), angle * direction);
                cube.quaternion.multiplyQuaternions(quaternion, cube.quaternion);
            });
        }
        
        function updateGameInfo() {
            document.getElementById('move-counter').textContent = `手数: ${moveCount}`;
        }
        
        function checkSolved() {
            if (!isGameMode) return;
            
            const isSolved = isInSolvedState();
            if (isSolved) {
                isGameMode = false;
                updateGameInfo();
                // 完成メッセージを削除
            }
        }
        
        function isInSolvedState() {
            // X-cross完成状態の判定
            // 各キューブが正しい位置と向きにあるかをチェック
            
            let solvedCount = 0;
            const totalCubes = cubeGroup.children.length;
            
            cubeGroup.children.forEach((cube, index) => {
                const x = index % 3;
                const y = Math.floor((index % 9) / 3);
                const z = Math.floor(index / 9);
                
                const expectedPos = new THREE.Vector3(
                    (x - 1) * 0.95,
                    (y - 1) * 0.95,
                    (z - 1) * 0.95
                );
                
                // 位置の許容誤差
                const positionTolerance = 0.1;
                const isInCorrectPosition = cube.position.distanceTo(expectedPos) < positionTolerance;
                
                // 回転の許容誤差（四元数で判定）
                const expectedQuat = new THREE.Quaternion(0, 0, 0, 1);
                const rotationTolerance = 0.1;
                const isInCorrectRotation = Math.abs(cube.quaternion.w - expectedQuat.w) < rotationTolerance &&
                                          Math.abs(cube.quaternion.x - expectedQuat.x) < rotationTolerance &&
                                          Math.abs(cube.quaternion.y - expectedQuat.y) < rotationTolerance &&
                                          Math.abs(cube.quaternion.z - expectedQuat.z) < rotationTolerance;
                
                if (isInCorrectPosition && isInCorrectRotation) {
                    solvedCount++;
                }
            });
            
            // 80%以上のキューブが正しい位置にあれば完成とみなす（簡略化された判定）
            return solvedCount >= totalCubes * 0.8;
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

            // 初期化実行
            init();
            updateGameInfo();
    </script>
</body>
</html>
