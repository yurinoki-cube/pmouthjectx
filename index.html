<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D ãƒ«ãƒ¼ãƒ“ãƒƒã‚¯ã‚­ãƒ¥ãƒ¼ãƒ–</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 16px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.3);
            padding: 8px 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            cursor: pointer;
            transition: background 0.3s ease;
        }
        
        #info:hover {
            background: rgba(0, 0, 0, 0.4);
        }
        
        #info h3 {
            margin: 0;
        }
        
        #modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            display: none;
            justify-content: center;
            align-items: center;
        }
        
        #modal-content {
            background: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 15px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            color: #333;
        }
        
        #modal-content h2 {
            margin-top: 0;
            color: #4a5568;
            text-align: center;
            border-bottom: 2px solid #e2e8f0;
            padding-bottom: 10px;
        }
        
        #modal-content h3 {
            color: #2d3748;
            margin-top: 20px;
            margin-bottom: 10px;
        }
        
        #modal-content ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        
        #modal-content li {
            margin: 5px 0;
            line-height: 1.4;
        }
        
        .close-button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 20px;
            display: block;
            margin-left: auto;
            margin-right: auto;
        }
        
        .close-button:hover {
            background: #5a67d8;
        }
        
        #controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 100;
        }
        
        button {
            padding: 12px 20px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }
        
        button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }
        
        button:active {
            transform: translateY(0);
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="info" onclick="showControls()">
            <h3>ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆX</h3>
        </div>
        <div style="position: absolute; top: 70px; left: 20px; z-index: 100;">
            <button onclick="scrambleFromSolved(5)" style="padding: 12px 20px; background: rgba(255, 255, 255, 0.2); border: 2px solid rgba(255, 255, 255, 0.3); color: white; border-radius: 8px; cursor: pointer; font-size: 14px; transition: all 0.3s ease; backdrop-filter: blur(10px);" onmouseover="this.style.background='rgba(255, 255, 255, 0.3)'; this.style.transform='translateY(-2px)'" onmouseout="this.style.background='rgba(255, 255, 255, 0.2)'; this.style.transform='translateY(0)'">5æ‰‹å´©ã™</button>
        </div>
        <div id="controls">
            <button onclick="resetToScrambled()">ã‚¹ã‚¯ãƒ©ãƒ³ãƒ–ãƒ«<br>ãƒªã‚»ãƒƒãƒˆ</button>
            <button onclick="resetCamera()">ã‚«ãƒ¡ãƒ©<br>ãƒªã‚»ãƒƒãƒˆ</button>
        </div>
        <div id="game-info" style="position: absolute; top: 20px; right: 20px; color: white; background: rgba(0, 0, 0, 0.3); padding: 15px; border-radius: 10px; backdrop-filter: blur(10px);">
            <div id="move-counter">æ‰‹æ•°: 0</div>
            <div id="scramble-info"></div>
        </div>
        
        <!-- æ“ä½œæ–¹æ³•ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ— -->
        <div id="modal-overlay" onclick="hideControls()">
            <div id="modal-content" onclick="event.stopPropagation()">
                <h2>ğŸ“‹ æ“ä½œæ–¹æ³•</h2>
                
                <h3>ğŸ–±ï¸ ãƒã‚¦ã‚¹æ“ä½œ</h3>
                <ul>
                    <li><strong>ãƒ‰ãƒ©ãƒƒã‚°</strong>ï¼šã‚­ãƒ¥ãƒ¼ãƒ–ã‚’è‡ªç”±ã«å›è»¢</li>
                    <li><strong>ãƒ›ã‚¤ãƒ¼ãƒ«</strong>ï¼šã‚ºãƒ¼ãƒ ã‚¤ãƒ³ãƒ»ã‚ºãƒ¼ãƒ ã‚¢ã‚¦ãƒˆ</li>
                </ul>
                
                <h3>âŒ¨ï¸ ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰æ“ä½œï¼ˆã‚²ãƒ¼ãƒ ä¸­ã®ã¿ï¼‰</h3>
                <ul>
                    <li><strong>R, L, U, D, F, B</strong>ï¼šå„é¢ã®å›è»¢</li>
                    <li><strong>Shift + R, L, U, D, F, B</strong>ï¼šå„é¢ã®é€†å›è»¢</li>
                    <li><strong>Ctrl/Cmd + R, L, U, D, F, B</strong>ï¼šå„é¢ã®180åº¦å›è»¢</li>
                    <li><strong>Alt + U</strong>ï¼šUwï¼ˆä¸Šé¢ãƒ¯ã‚¤ãƒ‰å›è»¢ï¼‰</li>
                    <li><strong>Alt + Shift + U</strong>ï¼šUw'ï¼ˆä¸Šé¢ãƒ¯ã‚¤ãƒ‰å›è»¢ é€†ï¼‰</li>
                    <li><strong>y</strong>ï¼šã‚­ãƒ¥ãƒ¼ãƒ–å…¨ä½“ã®yè»¸å›è»¢ï¼ˆæŒã¡æ›¿ãˆï¼‰</li>
                    <li><strong>Shift + y</strong>ï¼šã‚­ãƒ¥ãƒ¼ãƒ–å…¨ä½“ã®yè»¸é€†å›è»¢</li>
                </ul>
                
                <h3>ğŸ® ã‚²ãƒ¼ãƒ ã®æµã‚Œ</h3>
                <ul>
                    <li><strong>ã€Œ5æ‰‹å´©ã™ã€</strong>ï¼šX-crosså®ŒæˆçŠ¶æ…‹ã‹ã‚‰5æ‰‹ã§ãƒ©ãƒ³ãƒ€ãƒ ã«å´©ã™</li>
                    <li><strong>ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰æ“ä½œ</strong>ï¼šX-crosså®ŒæˆçŠ¶æ…‹ã«æˆ»ã™</li>
                    <li><strong>ã€Œã‚¹ã‚¯ãƒ©ãƒ³ãƒ–ãƒ«ãƒªã‚»ãƒƒãƒˆã€</strong>ï¼šå´©ã—ãŸçŠ¶æ…‹ã«æˆ»ã™</li>
                    <li><strong>ã€Œã‚«ãƒ¡ãƒ©ãƒªã‚»ãƒƒãƒˆã€</strong>ï¼šè¦‹ãŸç›®ã‚’åˆæœŸçŠ¶æ…‹ã«æˆ»ã™</li>
                </ul>
                
                <h3>ğŸ“± ã‚¿ãƒƒãƒæ“ä½œ</h3>
                <ul>
                    <li><strong>ã‚¿ãƒƒãƒ&ãƒ‰ãƒ©ãƒƒã‚°</strong>ï¼šã‚­ãƒ¥ãƒ¼ãƒ–ã‚’å›è»¢</li>
                    <li><strong>ãƒ”ãƒ³ãƒ</strong>ï¼šã‚ºãƒ¼ãƒ ï¼ˆä¸€éƒ¨ãƒ‡ãƒã‚¤ã‚¹ï¼‰</li>
                </ul>
                
                <button class="close-button" onclick="hideControls()">é–‰ã˜ã‚‹</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, cube, cubeGroup;
        let mouseX = 0, mouseY = 0;
        let isMouseDown = false;
        let moveCount = 0;
        let isGameMode = false;
        let scrambleSequence = [];
        let solutionSequence = [];
        let cubeState = []; // ã‚­ãƒ¥ãƒ¼ãƒ–ã®çŠ¶æ…‹ã‚’ä¿å­˜
        
        // å›è»¢ã®å®šç¾©
        const moves = ['R', 'R\'', 'R2', 'L', 'L\'', 'L2', 'U', 'U\'', 'U2', 'Uw', 'Uw\'', 'D', 'D\'', 'D2', 'F', 'F\'', 'F2', 'B', 'B\'', 'B2'];
        
        // å®ŒæˆçŠ¶æ…‹ã®å®šç¾©
        const solvedState = {
            centers: true,
            whiteEdges: true,
            blueOrangeF2L: true
        };
        
        // ãƒ«ãƒ¼ãƒ“ãƒƒã‚¯ã‚­ãƒ¥ãƒ¼ãƒ–ã®è‰²å®šç¾©
        const colors = {
            front: 0xff0000,   // èµ¤
            back: 0xff8c00,    // ã‚ªãƒ¬ãƒ³ã‚¸  
            right: 0x00ff00,   // ç·‘
            left: 0x0000ff,    // é’
            top: 0xffffff,     // ç™½
            bottom: 0xffff00   // é»„
        };

        function init() {
            // ã‚·ãƒ¼ãƒ³ä½œæˆ
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);

            // ã‚«ãƒ¡ãƒ©ä½œæˆ
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(4, 3, 6);
            camera.lookAt(0, 0, 0);

            // ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ä½œæˆ
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);

            // ãƒ©ã‚¤ãƒ†ã‚£ãƒ³ã‚°
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // ãƒ«ãƒ¼ãƒ“ãƒƒã‚¯ã‚­ãƒ¥ãƒ¼ãƒ–ä½œæˆ
            createRubiksCube();

            // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
            setupEventListeners();

            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—é–‹å§‹
            animate();
        }

        function createRubiksCube() {
            cubeGroup = new THREE.Group();
            
            const cubeSize = 0.9;
            const gap = 0.05;
            const totalSize = cubeSize + gap;

            for (let x = 0; x < 3; x++) {
                for (let y = 0; y < 3; y++) {
                    for (let z = 0; z < 3; z++) {
                        // ã‚»ãƒ³ã‚¿ãƒ¼ãƒ‘ãƒ¼ãƒ„ã‹ã©ã†ã‹ã‚’åˆ¤å®š
                        const isCenter = (x === 1 && y === 1) || (x === 1 && z === 1) || (y === 1 && z === 1);
                        
                        // ç™½è‰²ã®ã‚¨ãƒƒã‚¸ãƒ‘ãƒ¼ãƒ„ã‹ã©ã†ã‹ã‚’åˆ¤å®šï¼ˆåº•é¢ã®åå­—ï¼‰
                        const isWhiteEdge = (y === 0) && // åº•é¢ã«ã‚ã‚‹
                                          ((x === 1 && z !== 1) || (z === 1 && x !== 1)); // ã‚¨ãƒƒã‚¸ã®ä½ç½®
                        
                        // é’ã¨ã‚ªãƒ¬ãƒ³ã‚¸ã®F2Lãƒšã‚¢ï¼ˆå·¦å´é¢-èƒŒé¢ã®ã‚³ãƒ¼ãƒŠãƒ¼ï¼‰ã‹ã©ã†ã‹ã‚’åˆ¤å®š
                        const isBlueOrangeF2L = (x === 0 && z === 0) && (y === 0 || y === 1); // å·¦å¾Œã®ã‚³ãƒ¼ãƒŠãƒ¼ã¨ã‚¨ãƒƒã‚¸ï¼ˆé’ã¯å·¦å´é¢ã€ã‚ªãƒ¬ãƒ³ã‚¸ã¯èƒŒé¢ï¼‰
                        
                        const smallCube = createSmallCube(cubeSize, isCenter, isWhiteEdge, isBlueOrangeF2L);
                        smallCube.position.set(
                            (x - 1) * totalSize,
                            (y - 1) * totalSize,
                            (z - 1) * totalSize
                        );
                        cubeGroup.add(smallCube);
                    }
                }
            }

            scene.add(cubeGroup);
        }

        function createSmallCube(size, isCenter = false, isWhiteEdge = false, isBlueOrangeF2L = false) {
            const geometry = new THREE.BoxGeometry(size, size, size);
            
            let materials;
            
            if (isCenter || isWhiteEdge || isBlueOrangeF2L) {
                // ã‚»ãƒ³ã‚¿ãƒ¼ãƒ‘ãƒ¼ãƒ„ã€ç™½è‰²ã‚¨ãƒƒã‚¸ãƒ‘ãƒ¼ãƒ„ã€ã¾ãŸã¯é’ã‚ªãƒ¬ãƒ³ã‚¸F2Lãƒšã‚¢ã¯å…ƒã®è‰²ã‚’ç¶­æŒ
                materials = [
                    new THREE.MeshLambertMaterial({ color: colors.right }),  // å³ï¼ˆç·‘ï¼‰
                    new THREE.MeshLambertMaterial({ color: colors.left }),   // å·¦ï¼ˆé’ï¼‰
                    new THREE.MeshLambertMaterial({ color: colors.bottom }), // ä¸Šï¼ˆé»„ï¼‰
                    new THREE.MeshLambertMaterial({ color: colors.top }),    // ä¸‹ï¼ˆç™½ï¼‰
                    new THREE.MeshLambertMaterial({ color: colors.front }),  // å‰ï¼ˆèµ¤ï¼‰
                    new THREE.MeshLambertMaterial({ color: colors.back })    // å¾Œï¼ˆã‚ªãƒ¬ãƒ³ã‚¸ï¼‰
                ];
            } else {
                // ãã®ä»–ã®ãƒ‘ãƒ¼ãƒ„ï¼ˆF2Lãƒšã‚¢ã‚’å«ã‚€ï¼‰ã¯ã™ã¹ã¦ã‚°ãƒ¬ãƒ¼
                const grayMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
                materials = [grayMaterial, grayMaterial, grayMaterial, grayMaterial, grayMaterial, grayMaterial];
            }

            const cube = new THREE.Mesh(geometry, materials);
            cube.castShadow = true;
            cube.receiveShadow = true;

            // ã‚¨ãƒƒã‚¸ã‚’è¿½åŠ ã—ã¦ã‚ˆã‚Šãƒªã‚¢ãƒ«ã«
            const edges = new THREE.EdgesGeometry(geometry);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 }));
            cube.add(line);

            return cube;
        }

        function setupEventListeners() {
            // ãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆ
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('wheel', onWheel);

            // ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆ
            renderer.domElement.addEventListener('touchstart', onTouchStart);
            renderer.domElement.addEventListener('touchmove', onTouchMove);
            renderer.domElement.addEventListener('touchend', onTouchEnd);

            // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆå›è»¢æ“ä½œç”¨ï¼‰
            window.addEventListener('keydown', onKeyDown);
            
            // ãƒªã‚µã‚¤ã‚ºã‚¤ãƒ™ãƒ³ãƒˆ
            window.addEventListener('resize', onWindowResize);
        }

        function onKeyDown(event) {
            if (!isGameMode) return;
            
            const key = event.key.toLowerCase();
            let move = '';
            
            switch(key) {
                case 'r': 
                    if (event.ctrlKey || event.metaKey) {
                        move = 'R2';
                    } else {
                        move = event.shiftKey ? 'R' : 'R\'';
                    }
                    break;
                case 'l': 
                    if (event.ctrlKey || event.metaKey) {
                        move = 'L2';
                    } else {
                        move = event.shiftKey ? 'L\'' : 'L';
                    }
                    break;
                case 'u': 
                    if (event.altKey) {
                        // Alt + U ã§ Uwï¼ˆãƒ¯ã‚¤ãƒ‰å›è»¢ï¼‰
                        move = event.shiftKey ? 'Uw' : 'Uw\'';
                    } else if (event.ctrlKey || event.metaKey) {
                        move = 'U2';
                    } else {
                        move = event.shiftKey ? 'U' : 'U\'';
                    }
                    break;
                case 'd': 
                    if (event.ctrlKey || event.metaKey) {
                        move = 'D2';
                    } else {
                        move = event.shiftKey ? 'D\'' : 'D';
                    }
                    break;
                case 'f': 
                    if (event.ctrlKey || event.metaKey) {
                        move = 'F2';
                    } else {
                        move = event.shiftKey ? 'F' : 'F\'';
                    }
                    break;
                case 'b': 
                    if (event.ctrlKey || event.metaKey) {
                        move = 'B2';
                    } else {
                        move = event.shiftKey ? 'B\'' : 'B';
                    }
                    break;
                case 'y': move = event.shiftKey ? 'y\'' : 'y'; break;
            }
            
            if (move) {
                if (move === 'y' || move === 'y\'') {
                    executeYRotation(move);
                } else {
                    executeMove(move);
                    moveCount++;
                }
                updateGameInfo();
                checkSolved();
            }
        }

        function onMouseDown(event) {
            isMouseDown = true;
            mouseX = event.clientX;
            mouseY = event.clientY;
        }

        function onMouseMove(event) {
            if (!isMouseDown) return;

            const deltaX = event.clientX - mouseX;
            const deltaY = event.clientY - mouseY;

            cubeGroup.rotation.y += deltaX * 0.01;
            cubeGroup.rotation.x += deltaY * 0.01;

            mouseX = event.clientX;
            mouseY = event.clientY;
        }

        function onMouseUp(event) {
            isMouseDown = false;
        }

        function onWheel(event) {
            camera.position.multiplyScalar(event.deltaY > 0 ? 1.1 : 0.9);
            camera.position.clampLength(3, 20);
        }

        function onTouchStart(event) {
            if (event.touches.length === 1) {
                mouseX = event.touches[0].clientX;
                mouseY = event.touches[0].clientY;
                isMouseDown = true;
            }
        }

        function onTouchMove(event) {
            event.preventDefault();
            if (event.touches.length === 1 && isMouseDown) {
                const deltaX = event.touches[0].clientX - mouseX;
                const deltaY = event.touches[0].clientY - mouseY;

                cubeGroup.rotation.y += deltaX * 0.01;
                cubeGroup.rotation.x += deltaY * 0.01;

                mouseX = event.touches[0].clientX;
                mouseY = event.touches[0].clientY;
            }
        }

        function onTouchEnd(event) {
            isMouseDown = false;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function scrambleCube() {
            cubeGroup.children.forEach(cube => {
                // ãƒ©ãƒ³ãƒ€ãƒ ãªä½ç½®ã«ç§»å‹•
                cube.position.add(new THREE.Vector3(
                    (Math.random() - 0.5) * 0.2,
                    (Math.random() - 0.5) * 0.2,
                    (Math.random() - 0.5) * 0.2
                ));
                
                // ãƒ©ãƒ³ãƒ€ãƒ ãªå›è»¢
                cube.rotation.set(
                    Math.random() * Math.PI * 2,
                    Math.random() * Math.PI * 2,
                    Math.random() * Math.PI * 2
                );
            });
        }

        function showControls() {
            document.getElementById('modal-overlay').style.display = 'flex';
        }
        
        function hideControls() {
            document.getElementById('modal-overlay').style.display = 'none';
        }

        function resetCamera() {
            // ã‚«ãƒ¡ãƒ©ã‚’åˆæœŸä½ç½®ã«æˆ»ã™
            camera.position.set(4, 3, 6);
            camera.lookAt(0, 0, 0);
            camera.up.set(0, 1, 0); // ã‚«ãƒ¡ãƒ©ã®ä¸Šæ–¹å‘ã‚’ãƒªã‚»ãƒƒãƒˆ
            camera.updateProjectionMatrix();
            camera.updateMatrixWorld();
            
            // ã‚­ãƒ¥ãƒ¼ãƒ–ã®å›è»¢ã‚‚ãƒªã‚»ãƒƒãƒˆ
            cubeGroup.rotation.set(0, 0, 0);
        }

        function resetCube() {
            cubeGroup.children.forEach((cube, index) => {
                const x = index % 3;
                const y = Math.floor((index % 9) / 3);
                const z = Math.floor(index / 9);
                
                const cubeSize = 0.9;
                const gap = 0.05;
                const totalSize = cubeSize + gap;
                
                // ä½ç½®ã‚’ãƒªã‚»ãƒƒãƒˆ
                cube.position.set(
                    (x - 1) * totalSize,
                    (y - 1) * totalSize,
                    (z - 1) * totalSize
                );
                
                // å›è»¢ã‚’ãƒªã‚»ãƒƒãƒˆ
                cube.rotation.set(0, 0, 0);
                cube.quaternion.set(0, 0, 0, 1);
            });
            
            // ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
            moveCount = 0;
            isGameMode = false;
            scrambleSequence = [];
            solutionSequence = [];
            updateGameInfo();
            document.getElementById('scramble-info').innerHTML = '';
        }

        let scrambledState = null; // 5æ‰‹å´©ã—ãŸçŠ¶æ…‹ã‚’ä¿å­˜

        function scrambleFromSolved(numMoves) {
            resetCube();
            scrambleSequence = [];
            solutionSequence = [];
            
            // ãƒ©ãƒ³ãƒ€ãƒ ãªæ‰‹é †ã‚’ç”Ÿæˆ
            for (let i = 0; i < numMoves; i++) {
                let randomMove;
                do {
                    randomMove = moves[Math.floor(Math.random() * moves.length)];
                } while (scrambleSequence.length > 0 && isOppositeMove(randomMove, scrambleSequence[scrambleSequence.length - 1]));
                
                scrambleSequence.push(randomMove);
                // è§£æ³•ã¯é€†é †ã§é€†ã®æ‰‹é †
                solutionSequence.unshift(getInverseMove(randomMove));
            }
            
            // ã‚¹ã‚¯ãƒ©ãƒ³ãƒ–ãƒ«ã‚’å®Ÿè¡Œï¼ˆè¦–è¦šçš„ã«ã¯è¦‹ã›ãªã„ï¼‰
            scrambleSequence.forEach(move => {
                executeMove(move, false);
            });
            
            // å´©ã—ãŸçŠ¶æ…‹ã‚’ä¿å­˜
            scrambledState = cubeGroup.children.map(cube => ({
                position: cube.position.clone(),
                quaternion: cube.quaternion.clone()
            }));
            
            // ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰é–‹å§‹
            moveCount = 0;
            isGameMode = true;
            updateGameInfo();
            
            // è¡¨ç¤ºç”¨ã®ã‚¹ã‚¯ãƒ©ãƒ³ãƒ–ãƒ«ã¨è§£æ³•ã‚’ä¿®æ­£ï¼ˆR, U, F, Uwã®å›è»¢ã‚’é€†ã«è¡¨ç¤ºï¼‰
            const displayScramble = scrambleSequence.map(move => {
                if (move.includes('2')) {
                    return move; // 180åº¦å›è»¢ã¯ãã®ã¾ã¾
                }
                const base = move.replace('\'', '').replace('w', '');
                if (base === 'R' || base === 'U' || base === 'F') {
                    return move.includes('\'') ? move.replace('\'', '') : move + '\'';
                }
                return move;
            });
            
            const displaySolution = solutionSequence.map(move => {
                if (move.includes('2')) {
                    return move; // 180åº¦å›è»¢ã¯ãã®ã¾ã¾
                }
                const base = move.replace('\'', '').replace('w', '');
                if (base === 'R' || base === 'U' || base === 'F') {
                    return move.includes('\'') ? move.replace('\'', '') : move + '\'';
                }
                return move;
            });
            
            document.getElementById('scramble-info').innerHTML = 
                `ã‚¹ã‚¯ãƒ©ãƒ³ãƒ–ãƒ«: ${displayScramble.join(' ')}<br>` +
                `è§£æ³•: ${displaySolution.join(' ')}`;
        }
        
        function resetToScrambled() {
            if (!scrambledState) {
                alert('ã¾ãšã€Œ5æ‰‹å´©ã™ã€ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ã‚²ãƒ¼ãƒ ã‚’é–‹å§‹ã—ã¦ãã ã•ã„ã€‚');
                return;
            }
            
            // 5æ‰‹å´©ã—ãŸçŠ¶æ…‹ã«æˆ»ã™
            cubeGroup.children.forEach((cube, index) => {
                cube.position.copy(scrambledState[index].position);
                cube.quaternion.copy(scrambledState[index].quaternion);
            });
            
            // æ‰‹æ•°ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã‚’ãƒªã‚»ãƒƒãƒˆ
            moveCount = 0;
            isGameMode = true;
            updateGameInfo();
        }
        
        function isOppositeMove(move1, move2) {
            const base1 = move1.replace('\'', '');
            const base2 = move2.replace('\'', '');
            return base1 === base2;
        }
        
        function getInverseMove(move) {
            // 180åº¦å›è»¢ã®å ´åˆã¯åŒã˜æ‰‹é †
            if (move.includes('2')) {
                return move;
            }
            
            // R, U, Fï¼ˆãŠã‚ˆã³Uwï¼‰ã¯è¡¨ç¤ºä¸Šé€†ã«ã™ã‚‹å¿…è¦ãŒã‚ã‚‹
            const base = move.replace('\'', '').replace('w', '');
            if (base === 'R' || base === 'U' || base === 'F') {
                return move.includes('\'') ? move.replace('\'', '') : move + '\'';
            } else {
                return move.includes('\'') ? move.replace('\'', '') : move + '\'';
            }
        }
        
        function executeMove(move, animate = true) {
            // å®Ÿéš›ã®å›è»¢ã‚’å®Ÿè¡Œï¼ˆç°¡ç•¥åŒ–ç‰ˆï¼‰
            let angle = Math.PI / 2;
            
            // 180åº¦å›è»¢ã®å ´åˆ
            if (move.includes('2')) {
                angle = Math.PI;
            }
            
            const rotationAxis = getRotationAxis(move);
            let direction = 1;
            
            // é€†å›è»¢ã®å ´åˆ
            if (move.includes('\'')) {
                direction = -1;
            }
            // 180åº¦å›è»¢ã®å ´åˆã¯æ–¹å‘ã¯é–¢ä¿‚ãªã„
            else if (move.includes('2')) {
                direction = 1;
            }
            
            // è©²å½“ã™ã‚‹é¢ã®ã‚­ãƒ¥ãƒ¼ãƒ–ã‚’é¸æŠã—ã¦å›è»¢
            const cubesToRotate = selectCubesToRotate(move);
            cubesToRotate.forEach(cube => {
                const quaternion = new THREE.Quaternion().setFromAxisAngle(rotationAxis, angle * direction);
                cube.position.applyQuaternion(quaternion);
                cube.quaternion.multiplyQuaternions(quaternion, cube.quaternion);
            });
        }
        
        function getRotationAxis(move) {
            const base = move.replace('\'', '').replace('2', '').replace('w', '');
            switch(base) {
                case 'R': case 'L': return new THREE.Vector3(1, 0, 0);
                case 'U': case 'D': return new THREE.Vector3(0, 1, 0);
                case 'F': case 'B': return new THREE.Vector3(0, 0, 1);
                default: return new THREE.Vector3(0, 1, 0);
            }
        }
        
        function selectCubesToRotate(move) {
            return cubeGroup.children.filter((cube, index) => {
                const pos = cube.position;
                const base = move.replace('\'', '').replace('2', '');
                
                // Uwã®å ´åˆã¯ä¸Šé¢2å±¤ã‚’å›è»¢
                if (base === 'Uw') {
                    return pos.y >= -0.5; // ä¸­æ®µã¨ä¸Šæ®µ
                }
                
                const cleanBase = base.replace('w', '');
                switch(cleanBase) {
                    case 'R': return pos.x > 0.5;
                    case 'L': return pos.x < -0.5;
                    case 'U': return pos.y > 0.5;
                    case 'D': return pos.y < -0.5;
                    case 'F': return pos.z > 0.5;
                    case 'B': return pos.z < -0.5;
                    default: return false;
                }
            });
        }
        
        function executeYRotation(move) {
            // ã‚­ãƒ¥ãƒ¼ãƒ–å…¨ä½“ã‚’yè»¸å›è»¢ï¼ˆæŒã¡æ›¿ãˆï¼‰
            const angle = Math.PI / 2;
            const direction = move.includes('\'') ? 1 : -1; // yã®æ–¹å‘ã‚’èª¿æ•´
            
            cubeGroup.children.forEach(cube => {
                // å„ã‚­ãƒ¥ãƒ¼ãƒ–ã®ä½ç½®ã‚’yè»¸ä¸­å¿ƒã«å›è»¢
                const pos = cube.position.clone();
                const newX = pos.z * direction;
                const newZ = -pos.x * direction;
                cube.position.set(newX, pos.y, newZ);
                
                // å„ã‚­ãƒ¥ãƒ¼ãƒ–è‡ªä½“ã‚‚yè»¸å›è»¢
                const quaternion = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), angle * direction);
                cube.quaternion.multiplyQuaternions(quaternion, cube.quaternion);
            });
        }
        
        function updateGameInfo() {
            document.getElementById('move-counter').textContent = `æ‰‹æ•°: ${moveCount}`;
        }
        
        function checkSolved() {
            if (!isGameMode) return;
            
            const isSolved = isInSolvedState();
            if (isSolved) {
                isGameMode = false;
                alert(`ãŠã‚ã§ã¨ã†ã”ã–ã„ã¾ã™ï¼${moveCount}æ‰‹ã§X-crossãŒå®Œæˆã—ã¾ã—ãŸï¼`);
                updateGameInfo();
            }
        }
        
        function isInSolvedState() {
            // X-crosså®ŒæˆçŠ¶æ…‹ã®åˆ¤å®š
            // å„ã‚­ãƒ¥ãƒ¼ãƒ–ãŒæ­£ã—ã„ä½ç½®ã¨å‘ãã«ã‚ã‚‹ã‹ã‚’ãƒã‚§ãƒƒã‚¯
            
            let solvedCount = 0;
            const totalCubes = cubeGroup.children.length;
            
            cubeGroup.children.forEach((cube, index) => {
                const x = index % 3;
                const y = Math.floor((index % 9) / 3);
                const z = Math.floor(index / 9);
                
                const expectedPos = new THREE.Vector3(
                    (x - 1) * 0.95,
                    (y - 1) * 0.95,
                    (z - 1) * 0.95
                );
                
                // ä½ç½®ã®è¨±å®¹èª¤å·®
                const positionTolerance = 0.1;
                const isInCorrectPosition = cube.position.distanceTo(expectedPos) < positionTolerance;
                
                // å›è»¢ã®è¨±å®¹èª¤å·®ï¼ˆå››å…ƒæ•°ã§åˆ¤å®šï¼‰
                const expectedQuat = new THREE.Quaternion(0, 0, 0, 1);
                const rotationTolerance = 0.1;
                const isInCorrectRotation = Math.abs(cube.quaternion.w - expectedQuat.w) < rotationTolerance &&
                                          Math.abs(cube.quaternion.x - expectedQuat.x) < rotationTolerance &&
                                          Math.abs(cube.quaternion.y - expectedQuat.y) < rotationTolerance &&
                                          Math.abs(cube.quaternion.z - expectedQuat.z) < rotationTolerance;
                
                if (isInCorrectPosition && isInCorrectRotation) {
                    solvedCount++;
                }
            });
            
            // 80%ä»¥ä¸Šã®ã‚­ãƒ¥ãƒ¼ãƒ–ãŒæ­£ã—ã„ä½ç½®ã«ã‚ã‚Œã°å®Œæˆã¨ã¿ãªã™ï¼ˆç°¡ç•¥åŒ–ã•ã‚ŒãŸåˆ¤å®šï¼‰
            return solvedCount >= totalCubes * 0.8;
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

            // åˆæœŸåŒ–å®Ÿè¡Œ
            init();
            updateGameInfo();
    </script>
</body>
</html>
