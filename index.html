<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D ルービックキューブ</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 16px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.3);
            padding: 8px 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            cursor: pointer;
            transition: background 0.3s ease;
        }
        
        #info:hover {
            background: rgba(0, 0, 0, 0.4);
        }
        
        #info h3 {
            margin: 0;
        }
        
        #modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            display: none;
            justify-content: center;
            align-items: center;
        }
        
        #modal-content {
            background: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 15px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            color: #333;
        }
        
        #modal-content h2 {
            margin-top: 0;
            color: #4a5568;
            text-align: center;
            border-bottom: 2px solid #e2e8f0;
            padding-bottom: 10px;
        }
        
        #modal-content h3 {
            color: #2d3748;
            margin-top: 20px;
            margin-bottom: 10px;
        }
        
        #modal-content ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        
        #modal-content li {
            margin: 5px 0;
            line-height: 1.4;
        }
        
        .close-button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 20px;
            display: block;
            margin-left: auto;
            margin-right: auto;
        }
        
        .close-button:hover {
            background: #5a67d8;
        }
        
        #controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 100;
        }
        
        button {
            padding: 12px 20px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }
        
        button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }
        
        button:active {
            transform: translateY(0);
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="info" onclick="showControls()">
            <h3>プロジェクトX</h3>
        </div>
        <div style="position: absolute; top: 70px; left: 20px; z-index: 100;">
            <button onclick="scrambleFromSolved(5)" style="padding: 12px 20px; background: rgba(255, 255, 255, 0.2); border: 2px solid rgba(255, 255, 255, 0.3); color: white; border-radius: 8px; cursor: pointer; font-size: 14px; transition: all 0.3s ease; backdrop-filter: blur(10px);" onmouseover="this.style.background='rgba(255, 255, 255, 0.3)'; this.style.transform='translateY(-2px)'" onmouseout="this.style.background='rgba(255, 255, 255, 0.2)'; this.style.transform='translateY(0)'">5手崩す</button>
        </div>
        <div id="controls">
            <button onclick="resetToScrambled()">スクランブル<br>リセット</button>
            <button onclick="resetCamera()">カメラ<br>リセット</button>
        </div>
        <div id="game-info" style="position: absolute; top: 20px; right: 20px; color: white; background: rgba(0, 0, 0, 0.3); padding: 15px; border-radius: 10px; backdrop-filter: blur(10px);">
            <div id="move-counter">手数: 0</div>
            <div id="scramble-info"></div>
        </div>
        
        <!-- 操作方法ポップアップ -->
        <div id="modal-overlay" onclick="hideControls()">
            <div id="modal-content" onclick="event.stopPropagation()">
                <h2>📋 操作方法</h2>
                
                <h3>🖱️ マウス操作</h3>
                <ul>
                    <li><strong>ドラッグ</strong>：キューブを自由に回転</li>
                    <li><strong>ホイール</strong>：ズームイン・ズームアウト</li>
                </ul>
                
                <h3>⌨️ キーボード操作（ゲーム中のみ）</h3>
                <ul>
                    <li><strong>R, L, U, D, F, B</strong>：各面の回転</li>
                    <li><strong>Shift + R, L, U, D, F, B</strong>：各面の逆回転</li>
                    <li><strong>Ctrl/Cmd + R, L, U, D, F, B</strong>：各面の180度回転</li>
                    <li><strong>Alt + U</strong>：Uw（上面ワイド回転）</li>
                    <li><strong>Alt + Shift + U</strong>：Uw'（上面ワイド回転 逆）</li>
                    <li><strong>y</strong>：キューブ全体のy軸回転（持ち替え）</li>
                    <li><strong>Shift + y</strong>：キューブ全体のy軸逆回転</li>
                </ul>
                
                <h3>🎮 ゲームの流れ</h3>
                <ul>
                    <li><strong>「5手崩す」</strong>：X-cross完成状態から5手でランダムに崩す</li>
                    <li><strong>キーボード操作</strong>：X-cross完成状態に戻す</li>
                    <li><strong>「スクランブルリセット」</strong>：崩した状態に戻す</li>
                    <li><strong>「カメラリセット」</strong>：見た目を初期状態に戻す</li>
                </ul>
                
                <h3>📱 タッチ操作</h3>
                <ul>
                    <li><strong>タッチ&ドラッグ</strong>：キューブを回転</li>
                    <li><strong>ピンチ</strong>：ズーム（一部デバイス）</li>
                </ul>
                
                <button class="close-button" onclick="hideControls()">閉じる</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, cube, cubeGroup;
        let mouseX = 0, mouseY = 0;
        let isMouseDown = false;
        let moveCount = 0;
        let isGameMode = false;
        let scrambleSequence = [];
        let solutionSequence = [];
        let cubeState = []; // キューブの状態を保存
        
        // 回転の定義
        const moves = ['R', 'R\'', 'R2', 'L', 'L\'', 'L2', 'U', 'U\'', 'U2', 'Uw', 'Uw\'', 'D', 'D\'', 'D2', 'F', 'F\'', 'F2', 'B', 'B\'', 'B2'];
        
        // 完成状態の定義
        const solvedState = {
            centers: true,
            whiteEdges: true,
            blueOrangeF2L: true
        };
        
        // ルービックキューブの色定義
        const colors = {
            front: 0xff0000,   // 赤
            back: 0xff8c00,    // オレンジ  
            right: 0x00ff00,   // 緑
            left: 0x0000ff,    // 青
            top: 0xffffff,     // 白
            bottom: 0xffff00   // 黄
        };

        function init() {
            // シーン作成
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);

            // カメラ作成
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(4, 3, 6);
            camera.lookAt(0, 0, 0);

            // レンダラー作成
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);

            // ライティング
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // ルービックキューブ作成
            createRubiksCube();

            // イベントリスナー
            setupEventListeners();

            // アニメーションループ開始
            animate();
        }

        function createRubiksCube() {
            cubeGroup = new THREE.Group();
            
            const cubeSize = 0.9;
            const gap = 0.05;
            const totalSize = cubeSize + gap;

            for (let x = 0; x < 3; x++) {
                for (let y = 0; y < 3; y++) {
                    for (let z = 0; z < 3; z++) {
                        // センターパーツかどうかを判定
                        const isCenter = (x === 1 && y === 1) || (x === 1 && z === 1) || (y === 1 && z === 1);
                        
                        // 白色のエッジパーツかどうかを判定（底面の十字）
                        const isWhiteEdge = (y === 0) && // 底面にある
                                          ((x === 1 && z !== 1) || (z === 1 && x !== 1)); // エッジの位置
                        
                        // 青とオレンジのF2Lペア（左側面-背面のコーナー）かどうかを判定
                        const isBlueOrangeF2L = (x === 0 && z === 0) && (y === 0 || y === 1); // 左後のコーナーとエッジ（青は左側面、オレンジは背面）
                        
                        const smallCube = createSmallCube(cubeSize, isCenter, isWhiteEdge, isBlueOrangeF2L);
                        smallCube.position.set(
                            (x - 1) * totalSize,
                            (y - 1) * totalSize,
                            (z - 1) * totalSize
                        );
                        cubeGroup.add(smallCube);
                    }
                }
            }

            scene.add(cubeGroup);
        }

        function createSmallCube(size, isCenter = false, isWhiteEdge = false, isBlueOrangeF2L = false) {
            const geometry = new THREE.BoxGeometry(size, size, size);
            
            let materials;
            
            if (isCenter || isWhiteEdge || isBlueOrangeF2L) {
                // センターパーツ、白色エッジパーツ、または青オレンジF2Lペアは元の色を維持
                materials = [
                    new THREE.MeshLambertMaterial({ color: colors.right }),  // 右（緑）
                    new THREE.MeshLambertMaterial({ color: colors.left }),   // 左（青）
                    new THREE.MeshLambertMaterial({ color: colors.bottom }), // 上（黄）
                    new THREE.MeshLambertMaterial({ color: colors.top }),    // 下（白）
                    new THREE.MeshLambertMaterial({ color: colors.front }),  // 前（赤）
                    new THREE.MeshLambertMaterial({ color: colors.back })    // 後（オレンジ）
                ];
            } else {
                // その他のパーツ（F2Lペアを含む）はすべてグレー
                const grayMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
                materials = [grayMaterial, grayMaterial, grayMaterial, grayMaterial, grayMaterial, grayMaterial];
            }

            const cube = new THREE.Mesh(geometry, materials);
            cube.castShadow = true;
            cube.receiveShadow = true;

            // エッジを追加してよりリアルに
            const edges = new THREE.EdgesGeometry(geometry);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 }));
            cube.add(line);

            return cube;
        }

        function setupEventListeners() {
            // マウスイベント
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('wheel', onWheel);

            // タッチイベント
            renderer.domElement.addEventListener('touchstart', onTouchStart);
            renderer.domElement.addEventListener('touchmove', onTouchMove);
            renderer.domElement.addEventListener('touchend', onTouchEnd);

            // キーボードイベント（回転操作用）
            window.addEventListener('keydown', onKeyDown);
            
            // リサイズイベント
            window.addEventListener('resize', onWindowResize);
        }

        function onKeyDown(event) {
            if (!isGameMode) return;
            
            const key = event.key.toLowerCase();
            let move = '';
            
            switch(key) {
                case 'r': 
                    if (event.ctrlKey || event.metaKey) {
                        move = 'R2';
                    } else {
                        move = event.shiftKey ? 'R' : 'R\'';
                    }
                    break;
                case 'l': 
                    if (event.ctrlKey || event.metaKey) {
                        move = 'L2';
                    } else {
                        move = event.shiftKey ? 'L\'' : 'L';
                    }
                    break;
                case 'u': 
                    if (event.altKey) {
                        // Alt + U で Uw（ワイド回転）
                        move = event.shiftKey ? 'Uw' : 'Uw\'';
                    } else if (event.ctrlKey || event.metaKey) {
                        move = 'U2';
                    } else {
                        move = event.shiftKey ? 'U' : 'U\'';
                    }
                    break;
                case 'd': 
                    if (event.ctrlKey || event.metaKey) {
                        move = 'D2';
                    } else {
                        move = event.shiftKey ? 'D\'' : 'D';
                    }
                    break;
                case 'f': 
                    if (event.ctrlKey || event.metaKey) {
                        move = 'F2';
                    } else {
                        move = event.shiftKey ? 'F' : 'F\'';
                    }
                    break;
                case 'b': 
                    if (event.ctrlKey || event.metaKey) {
                        move = 'B2';
                    } else {
                        move = event.shiftKey ? 'B\'' : 'B';
                    }
                    break;
                case 'y': move = event.shiftKey ? 'y\'' : 'y'; break;
            }
            
            if (move) {
                if (move === 'y' || move === 'y\'') {
                    executeYRotation(move);
                } else {
                    executeMove(move);
                    moveCount++;
                }
                updateGameInfo();
                checkSolved();
            }
        }

        function onMouseDown(event) {
            isMouseDown = true;
            mouseX = event.clientX;
            mouseY = event.clientY;
        }

        function onMouseMove(event) {
            if (!isMouseDown) return;

            const deltaX = event.clientX - mouseX;
            const deltaY = event.clientY - mouseY;

            cubeGroup.rotation.y += deltaX * 0.01;
            cubeGroup.rotation.x += deltaY * 0.01;

            mouseX = event.clientX;
            mouseY = event.clientY;
        }

        function onMouseUp(event) {
            isMouseDown = false;
        }

        function onWheel(event) {
            camera.position.multiplyScalar(event.deltaY > 0 ? 1.1 : 0.9);
            camera.position.clampLength(3, 20);
        }

        function onTouchStart(event) {
            if (event.touches.length === 1) {
                mouseX = event.touches[0].clientX;
                mouseY = event.touches[0].clientY;
                isMouseDown = true;
            }
        }

        function onTouchMove(event) {
            event.preventDefault();
            if (event.touches.length === 1 && isMouseDown) {
                const deltaX = event.touches[0].clientX - mouseX;
                const deltaY = event.touches[0].clientY - mouseY;

                cubeGroup.rotation.y += deltaX * 0.01;
                cubeGroup.rotation.x += deltaY * 0.01;

                mouseX = event.touches[0].clientX;
                mouseY = event.touches[0].clientY;
            }
        }

        function onTouchEnd(event) {
            isMouseDown = false;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function scrambleCube() {
            cubeGroup.children.forEach(cube => {
                // ランダムな位置に移動
                cube.position.add(new THREE.Vector3(
                    (Math.random() - 0.5) * 0.2,
                    (Math.random() - 0.5) * 0.2,
                    (Math.random() - 0.5) * 0.2
                ));
                
                // ランダムな回転
                cube.rotation.set(
                    Math.random() * Math.PI * 2,
                    Math.random() * Math.PI * 2,
                    Math.random() * Math.PI * 2
                );
            });
        }

        function showControls() {
            document.getElementById('modal-overlay').style.display = 'flex';
        }
        
        function hideControls() {
            document.getElementById('modal-overlay').style.display = 'none';
        }

        function resetCamera() {
            // カメラを初期位置に戻す
            camera.position.set(4, 3, 6);
            camera.lookAt(0, 0, 0);
            camera.up.set(0, 1, 0); // カメラの上方向をリセット
            camera.updateProjectionMatrix();
            camera.updateMatrixWorld();
            
            // キューブの回転もリセット
            cubeGroup.rotation.set(0, 0, 0);
        }

        function resetCube() {
            cubeGroup.children.forEach((cube, index) => {
                const x = index % 3;
                const y = Math.floor((index % 9) / 3);
                const z = Math.floor(index / 9);
                
                const cubeSize = 0.9;
                const gap = 0.05;
                const totalSize = cubeSize + gap;
                
                // 位置をリセット
                cube.position.set(
                    (x - 1) * totalSize,
                    (y - 1) * totalSize,
                    (z - 1) * totalSize
                );
                
                // 回転をリセット
                cube.rotation.set(0, 0, 0);
                cube.quaternion.set(0, 0, 0, 1);
            });
            
            // ゲーム状態をリセット
            moveCount = 0;
            isGameMode = false;
            scrambleSequence = [];
            solutionSequence = [];
            updateGameInfo();
            document.getElementById('scramble-info').innerHTML = '';
        }

        let scrambledState = null; // 5手崩した状態を保存

        function scrambleFromSolved(numMoves) {
            resetCube();
            scrambleSequence = [];
            solutionSequence = [];
            
            // ランダムな手順を生成
            for (let i = 0; i < numMoves; i++) {
                let randomMove;
                do {
                    randomMove = moves[Math.floor(Math.random() * moves.length)];
                } while (scrambleSequence.length > 0 && isOppositeMove(randomMove, scrambleSequence[scrambleSequence.length - 1]));
                
                scrambleSequence.push(randomMove);
                // 解法は逆順で逆の手順
                solutionSequence.unshift(getInverseMove(randomMove));
            }
            
            // スクランブルを実行（視覚的には見せない）
            scrambleSequence.forEach(move => {
                executeMove(move, false);
            });
            
            // 崩した状態を保存
            scrambledState = cubeGroup.children.map(cube => ({
                position: cube.position.clone(),
                quaternion: cube.quaternion.clone()
            }));
            
            // ゲームモード開始
            moveCount = 0;
            isGameMode = true;
            updateGameInfo();
            
            // 表示用のスクランブルと解法を修正（R, U, F, Uwの回転を逆に表示）
            const displayScramble = scrambleSequence.map(move => {
                if (move.includes('2')) {
                    return move; // 180度回転はそのまま
                }
                const base = move.replace('\'', '').replace('w', '');
                if (base === 'R' || base === 'U' || base === 'F') {
                    return move.includes('\'') ? move.replace('\'', '') : move + '\'';
                }
                return move;
            });
            
            const displaySolution = solutionSequence.map(move => {
                if (move.includes('2')) {
                    return move; // 180度回転はそのまま
                }
                const base = move.replace('\'', '').replace('w', '');
                if (base === 'R' || base === 'U' || base === 'F') {
                    return move.includes('\'') ? move.replace('\'', '') : move + '\'';
                }
                return move;
            });
            
            document.getElementById('scramble-info').innerHTML = 
                `スクランブル: ${displayScramble.join(' ')}<br>` +
                `解法: ${displaySolution.join(' ')}`;
        }
        
        function resetToScrambled() {
            if (!scrambledState) {
                alert('まず「5手崩す」ボタンを押してゲームを開始してください。');
                return;
            }
            
            // 5手崩した状態に戻す
            cubeGroup.children.forEach((cube, index) => {
                cube.position.copy(scrambledState[index].position);
                cube.quaternion.copy(scrambledState[index].quaternion);
            });
            
            // 手数カウンターをリセット
            moveCount = 0;
            isGameMode = true;
            updateGameInfo();
        }
        
        function isOppositeMove(move1, move2) {
            const base1 = move1.replace('\'', '');
            const base2 = move2.replace('\'', '');
            return base1 === base2;
        }
        
        function getInverseMove(move) {
            // 180度回転の場合は同じ手順
            if (move.includes('2')) {
                return move;
            }
            
            // R, U, F（およびUw）は表示上逆にする必要がある
            const base = move.replace('\'', '').replace('w', '');
            if (base === 'R' || base === 'U' || base === 'F') {
                return move.includes('\'') ? move.replace('\'', '') : move + '\'';
            } else {
                return move.includes('\'') ? move.replace('\'', '') : move + '\'';
            }
        }
        
        function executeMove(move, animate = true) {
            // 実際の回転を実行（簡略化版）
            let angle = Math.PI / 2;
            
            // 180度回転の場合
            if (move.includes('2')) {
                angle = Math.PI;
            }
            
            const rotationAxis = getRotationAxis(move);
            let direction = 1;
            
            // 逆回転の場合
            if (move.includes('\'')) {
                direction = -1;
            }
            // 180度回転の場合は方向は関係ない
            else if (move.includes('2')) {
                direction = 1;
            }
            
            // 該当する面のキューブを選択して回転
            const cubesToRotate = selectCubesToRotate(move);
            cubesToRotate.forEach(cube => {
                const quaternion = new THREE.Quaternion().setFromAxisAngle(rotationAxis, angle * direction);
                cube.position.applyQuaternion(quaternion);
                cube.quaternion.multiplyQuaternions(quaternion, cube.quaternion);
            });
        }
        
        function getRotationAxis(move) {
            const base = move.replace('\'', '').replace('2', '').replace('w', '');
            switch(base) {
                case 'R': case 'L': return new THREE.Vector3(1, 0, 0);
                case 'U': case 'D': return new THREE.Vector3(0, 1, 0);
                case 'F': case 'B': return new THREE.Vector3(0, 0, 1);
                default: return new THREE.Vector3(0, 1, 0);
            }
        }
        
        function selectCubesToRotate(move) {
            return cubeGroup.children.filter((cube, index) => {
                const pos = cube.position;
                const base = move.replace('\'', '').replace('2', '');
                
                // Uwの場合は上面2層を回転
                if (base === 'Uw') {
                    return pos.y >= -0.5; // 中段と上段
                }
                
                const cleanBase = base.replace('w', '');
                switch(cleanBase) {
                    case 'R': return pos.x > 0.5;
                    case 'L': return pos.x < -0.5;
                    case 'U': return pos.y > 0.5;
                    case 'D': return pos.y < -0.5;
                    case 'F': return pos.z > 0.5;
                    case 'B': return pos.z < -0.5;
                    default: return false;
                }
            });
        }
        
        function executeYRotation(move) {
            // キューブ全体をy軸回転（持ち替え）
            const angle = Math.PI / 2;
            const direction = move.includes('\'') ? 1 : -1; // yの方向を調整
            
            cubeGroup.children.forEach(cube => {
                // 各キューブの位置をy軸中心に回転
                const pos = cube.position.clone();
                const newX = pos.z * direction;
                const newZ = -pos.x * direction;
                cube.position.set(newX, pos.y, newZ);
                
                // 各キューブ自体もy軸回転
                const quaternion = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), angle * direction);
                cube.quaternion.multiplyQuaternions(quaternion, cube.quaternion);
            });
        }
        
        function updateGameInfo() {
            document.getElementById('move-counter').textContent = `手数: ${moveCount}`;
        }
        
        function checkSolved() {
            if (!isGameMode) return;
            
            const isSolved = isInSolvedState();
            if (isSolved) {
                isGameMode = false;
                alert(`おめでとうございます！${moveCount}手でX-crossが完成しました！`);
                updateGameInfo();
            }
        }
        
        function isInSolvedState() {
            // X-cross完成状態の判定
            // 各キューブが正しい位置と向きにあるかをチェック
            
            let solvedCount = 0;
            const totalCubes = cubeGroup.children.length;
            
            cubeGroup.children.forEach((cube, index) => {
                const x = index % 3;
                const y = Math.floor((index % 9) / 3);
                const z = Math.floor(index / 9);
                
                const expectedPos = new THREE.Vector3(
                    (x - 1) * 0.95,
                    (y - 1) * 0.95,
                    (z - 1) * 0.95
                );
                
                // 位置の許容誤差
                const positionTolerance = 0.1;
                const isInCorrectPosition = cube.position.distanceTo(expectedPos) < positionTolerance;
                
                // 回転の許容誤差（四元数で判定）
                const expectedQuat = new THREE.Quaternion(0, 0, 0, 1);
                const rotationTolerance = 0.1;
                const isInCorrectRotation = Math.abs(cube.quaternion.w - expectedQuat.w) < rotationTolerance &&
                                          Math.abs(cube.quaternion.x - expectedQuat.x) < rotationTolerance &&
                                          Math.abs(cube.quaternion.y - expectedQuat.y) < rotationTolerance &&
                                          Math.abs(cube.quaternion.z - expectedQuat.z) < rotationTolerance;
                
                if (isInCorrectPosition && isInCorrectRotation) {
                    solvedCount++;
                }
            });
            
            // 80%以上のキューブが正しい位置にあれば完成とみなす（簡略化された判定）
            return solvedCount >= totalCubes * 0.8;
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

            // 初期化実行
            init();
            updateGameInfo();
    </script>
</body>
</html>
